<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS基础</title>
    <url>/2022/01/18/CSS%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<blockquote>
<p>用来定义页面元素的样式</p>
</blockquote>
<ul>
<li>设置字体颜色</li>
<li>位置、大小</li>
<li>添加动画效果</li>
</ul>
<h2 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h2><p>样式规则</p>
<ul>
<li>选择器</li>
<li>属性</li>
<li>属性值</li>
<li>声明<ul>
<li>属性+属性值</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="样式来源"><a href="#样式来源" class="headerlink" title="样式来源"></a>样式来源</h2><ul>
<li>外联</li>
<li>内部</li>
<li>内联<ul>
<li>不需要写选择器</li>
</ul>
</li>
</ul>
<p>优先级：内联 &gt; 内部样式 &gt; 外联样式</p>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><table>
<thead>
<tr>
<th>选择器</th>
<th>用法</th>
<th>优先级权重</th>
</tr>
</thead>
<tbody><tr>
<td>标签选择器</td>
<td><code>div</code></td>
<td>1</td>
</tr>
<tr>
<td>类名选择器</td>
<td><code>.classname</code></td>
<td>10</td>
</tr>
<tr>
<td>id选择器</td>
<td><code>#id</code>，需要唯一</td>
<td>100</td>
</tr>
<tr>
<td>属性选择器</td>
<td><code>[]</code>，可以做匹配</td>
<td>10</td>
</tr>
<tr>
<td>通配选择器</td>
<td><code>*</code></td>
<td>0</td>
</tr>
<tr>
<td>伪类选择器</td>
<td><code>:</code>，分为状态伪类和结构伪类</td>
<td>10</td>
</tr>
<tr>
<td>伪元素选择器</td>
<td><code>::</code></td>
<td>1</td>
</tr>
</tbody></table>
<ul>
<li><code>!important</code>声明优先级最高</li>
<li>优先级相同，后出现样式生效</li>
</ul>
<h2 id="组合方式"><a href="#组合方式" class="headerlink" title="组合方式"></a>组合方式</h2><ul>
<li><code>AB</code>（直接组合）<ul>
<li>满足A，并且满足B</li>
</ul>
</li>
<li><code>A B</code>（后代组合）<ul>
<li>选中B，且B是A的后代</li>
</ul>
</li>
<li><code>A &gt; B</code>（亲子组合）<ul>
<li>选中B，且B是A的<strong>子代</strong></li>
</ul>
</li>
<li><code>A ~ B</code>（兄弟选择器）<ul>
<li>与A是同级，且在A后面的<strong>所有</strong>兄弟都会被选中</li>
</ul>
</li>
<li><code>A + B</code>（相邻选择器）<ul>
<li>选中B，B紧跟在A后面，A、B在同一级上</li>
</ul>
</li>
<li>选择器组<ul>
<li>逗号隔开</li>
</ul>
</li>
</ul>
<h2 id="CSS如何工作"><a href="#CSS如何工作" class="headerlink" title="CSS如何工作"></a>CSS如何工作</h2><p>解析HTML时，加载CSS，解析CSS，把样式添加到DOM节点</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>某些属性会自动继承父元素的<strong>计算值</strong>，除非显示指定一个值</p>
<ul>
<li>可以显性继承inherit</li>
</ul>
<h3 id="无继承属性"><a href="#无继承属性" class="headerlink" title="无继承属性"></a>无继承属性</h3><ul>
<li>盒子模型属性</li>
<li>定位属性<ul>
<li><code>float</code>、<code>position</code>、上下左右、<code>min-（长宽）</code>、<code>max-（长宽）</code></li>
</ul>
</li>
<li>轮廓样式<ul>
<li><code>outline</code>、<code>outline-（style、width、color）</code></li>
</ul>
</li>
<li>。。。</li>
</ul>
<h3 id="有继承属性"><a href="#有继承属性" class="headerlink" title="有继承属性"></a>有继承属性</h3><ul>
<li>字体属性</li>
<li>文本属性<ul>
<li><code>line-height</code>、<code>word-spacing</code>、<code>letter-spacing</code>、<code>text-indent</code>文本缩进</li>
</ul>
</li>
<li>列表布局</li>
</ul>
<h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>有两种，可以通过<code>box-sizing</code>设置</p>
<ul>
<li>标准盒模型<ul>
<li><code>content-box</code></li>
<li><code>width</code>、<code>height</code>的数值只是内容的宽高<ul>
<li><code>height</code>，容器有指定高度时，百分数才生效</li>
<li><code>width</code>，百分数相对于容器的content box宽度</li>
</ul>
</li>
</ul>
</li>
<li>怪异盒模型<ul>
<li><code>border-box</code></li>
<li><code>width</code>、<code>height</code>的数值等于（内容+内边距+边框）</li>
</ul>
</li>
</ul>
<h3 id="盒模型组成"><a href="#盒模型组成" class="headerlink" title="盒模型组成"></a>盒模型组成</h3><ul>
<li><code>content</code></li>
<li><code>padding</code><ul>
<li>百分数相对容器宽度</li>
</ul>
</li>
<li><code>border</code><ul>
<li><p><code>border-weight</code></p>
</li>
<li><p><code>border-style</code></p>
</li>
<li><p><code>border-color</code></p>
</li>
<li><p>可以画三角形</p>
</li>
</ul>
</li>
<li><code>margin</code><ul>
<li><code>margin</code> 重叠合并<ul>
<li>只在垂直方向</li>
</ul>
</li>
<li><code>margin:auto</code>可以水平居中</li>
<li>百分数相对于容器宽度</li>
</ul>
</li>
</ul>
<h2 id="块级、行级区别"><a href="#块级、行级区别" class="headerlink" title="块级、行级区别"></a>块级、行级区别</h2><h3 id="行级"><a href="#行级" class="headerlink" title="行级"></a>行级</h3><ul>
<li><code>display:inline</code></li>
<li>和其他行级盒子放在一行或拆成多行</li>
<li>盒模型中的<code>width</code>和<code>height</code>属性不能用</li>
<li>可以设置水平方向的<code>margin</code>和<code>padding</code>属性，单不能设置垂直方向的<code>margin</code>和<code>padding</code>属性</li>
<li>只包含行级盒子的容器会创建一个IFC<ul>
<li>盒子在一行水平摆放</li>
<li>一行放不下，换行显示</li>
<li><code>text-align</code>决定一行内盒子的水平对齐</li>
<li><code>vertical-align</code>决定垂直对齐</li>
<li>会避开浮动元素</li>
</ul>
</li>
</ul>
<h3 id="块级"><a href="#块级" class="headerlink" title="块级"></a>块级</h3><ul>
<li><code>display:block</code></li>
<li>不和其他盒子并列摆放</li>
<li>使用所有的盒模型属性</li>
<li><strong>某些</strong>（不是所有块级盒子）容器会创建一个BFC<ul>
<li>根元素</li>
<li>浮动、绝对定位、<code>inline-block</code></li>
<li>Flex子项、Grid子项</li>
<li><code>overflow</code>值不是<code>visible</code></li>
<li><code>display：flow-root</code></li>
<li>BFC排版规则<ul>
<li>盒子从上到下拜访</li>
<li><strong>垂直</strong><code>margin</code>合并</li>
<li>BFC内，盒子的<code>margin</code>不会与外面的合并</li>
<li>BFC不会和浮动元素重叠</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="inline-block"><a href="#inline-block" class="headerlink" title="inline-block"></a>inline-block</h3><ul>
<li>设置为<code>inline</code>对象，但呈现<strong>内容</strong>时作为<code>block</code>对象呈现</li>
<li>所以可以设置宽高</li>
</ul>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><ul>
<li>确定内容的大小和位置的算法</li>
<li>依据元素、容器、兄弟节点和内容等信息来计算</li>
</ul>
<h3 id="三大类"><a href="#三大类" class="headerlink" title="三大类"></a>三大类</h3><h4 id="常规流"><a href="#常规流" class="headerlink" title="常规流"></a>常规流</h4><ul>
<li><blockquote>
<p>大规则：块级从上到下，行级从左到右、根元素、浮动和绝对定位会脱离常规流</p>
</blockquote>
</li>
<li><p>行级</p>
</li>
<li><p>块级</p>
</li>
<li><p>表格布局</p>
</li>
<li><p>FlexBox</p>
<ul>
<li>控制摆放流向</li>
<li>摆放顺序</li>
<li>盒子宽带高度</li>
<li>水平垂直对齐</li>
<li>是否允许折行</li>
</ul>
</li>
<li><p>Grid布局</p>
</li>
</ul>
<h4 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h4><p>最早用于文字环绕图片</p>
<h4 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h4><h3 id="两栏布局实现"><a href="#两栏布局实现" class="headerlink" title="两栏布局实现"></a>两栏布局实现</h3><blockquote>
<p>左定宽，右自适应</p>
</blockquote>
<ul>
<li>左浮动，右<code>margin-left</code>值等于左宽</li>
<li>左浮动，右设置<code>overflow: hidden</code>触发BFC</li>
<li>用flex，左定宽，右设置<code>flex: 1</code>，容器<code>display: flex</code></li>
<li>用grid，容器<code>display: grid; grid-template-columns: 200px 1fr</code></li>
<li>左绝对定位，右<code>margin-left</code>设为左的宽度，父级元素记得设为非<code>static</code></li>
</ul>
<h3 id="三栏布局实现"><a href="#三栏布局实现" class="headerlink" title="三栏布局实现"></a>三栏布局实现</h3><p>详细请看<a href="https://sweet-kk.github.io/css-layout/">docsify文档网站</a></p>
<h2 id="理解BFC（块级格式上下文）"><a href="#理解BFC（块级格式上下文）" class="headerlink" title="理解BFC（块级格式上下文）"></a>理解BFC（块级格式上下文）</h2><p>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。</p>
<p>触发条件</p>
<ul>
<li>根元素<code>：body</code>；</li>
<li><code>float </code>除<code>none</code>以外的值；</li>
<li><code>position (absolute、fixed)</code>；</li>
<li><code>display </code>值为：<code>inline-block</code>、<code>table-cell</code>、<code>table-caption</code>、<code>flex</code>等；</li>
<li><code>overflow</code> 值为：<code>hidden</code>、<code>auto</code>、<code>scroll</code>；</li>
</ul>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>解决<code>margin</code>重叠问题</li>
<li>解决高度坍塌问题</li>
<li>清除浮动<ul>
<li>BFC区域不会与浮动的容器发生重叠</li>
</ul>
</li>
</ul>
<h2 id="flex语法及使用"><a href="#flex语法及使用" class="headerlink" title="flex语法及使用"></a>flex语法及使用</h2><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><ul>
<li><code>display:flex</code>，行内元素可以<code>display:inline-flex</code></li>
<li><code>flex-direction</code><ul>
<li><code>row,row-reverse,column,column-reverse</code></li>
</ul>
</li>
<li><code>flex-wrap</code><ul>
<li><code>nowrap,wrap,wrap-reverse</code></li>
</ul>
</li>
<li><code>justify-content</code><ul>
<li><code>flex-start,flex-end,center,space-between(两边靠边),space-around</code></li>
</ul>
</li>
<li><code>align-items</code><ul>
<li><code>flex-start,flex-end,center,baseline,stretch(默认值，将占满整个容器高度)</code></li>
</ul>
</li>
<li><code>align-content</code><ul>
<li>多个轴线对齐方式，只有一根，属性不起作用</li>
<li><code>flex-start,flex-end,center,space-between,space-around,stretch</code></li>
</ul>
</li>
</ul>
<h3 id="子项"><a href="#子项" class="headerlink" title="子项"></a>子项</h3><ul>
<li>order<ul>
<li>排列顺序，数值越小，排列越靠前，默认为0</li>
</ul>
</li>
<li>flex-grow<ul>
<li>放大比例，默认0，即如果存在剩余空间，也不放大</li>
</ul>
</li>
<li>flex-shrink<ul>
<li>缩小比例，默认为1，即如果空间不足，该项目将缩小。</li>
<li>负值无效</li>
</ul>
</li>
<li>flex-basis<ul>
<li>可以理解为content-box上width的值一样作用</li>
<li>默认值为<code>auto</code>，即项目的本来大小</li>
</ul>
</li>
<li>flex<ul>
<li>flex-grow,flex-shrink,flex-basis三个的简写</li>
<li>默认值0 1 auto</li>
<li>填auto，相当于（1 1 auto）</li>
<li>填none，相当于（0 0 auto）</li>
</ul>
</li>
<li>align-self<ul>
<li>单个子项的对齐方式</li>
<li>默认值auto，表示继承父元素的align-items属性，没有父元素，则等同stretch</li>
<li>auto,flex-start,flex-end,center,baseline,stretch</li>
</ul>
</li>
</ul>
<h2 id="Grid语法及使用"><a href="#Grid语法及使用" class="headerlink" title="Grid语法及使用"></a>Grid语法及使用</h2><p>二维布局</p>
<h3 id="容器-1"><a href="#容器-1" class="headerlink" title="容器"></a>容器</h3><ul>
<li>display:grid，行内元素也可以设成display: inline-grid</li>
<li>grid-template-columns<ul>
<li>定义每一列的列宽</li>
<li>单位可以时绝对单位，百分数，fr</li>
<li>属性值可以是repeat()函数<ul>
<li>此函数接受两个参数，第一个是重复次数（可以填auto-fil，表示自动填充），第二个是所要重复的值</li>
</ul>
</li>
<li>minmax()，接受两个参数（最小值和最大轴），产生一个长度范围</li>
<li>可以指定网格线名字<ul>
<li>例如：<code> [c1] 100px [c2] 100px [c3] auto [c4];</code></li>
</ul>
</li>
</ul>
</li>
<li>gird-template-rows<ul>
<li>定义每一行的行高</li>
<li>单位可以时绝对单位，百分数，fr</li>
<li>repeat()</li>
<li>minmax()</li>
<li>可以指定网格线名字</li>
</ul>
</li>
<li>grid-row-gap<ul>
<li>设置行与行的间隔</li>
</ul>
</li>
<li>gird-column-gap<ul>
<li>设置列与列的间隔</li>
</ul>
</li>
<li>grid-gap<ul>
<li>合并上面两个，先行后列</li>
</ul>
</li>
<li>grid-template-areas<ul>
<li>用于定义区域</li>
<li>如果某些区域不需要利用，则使用”点”（<code>.</code>）表示</li>
</ul>
</li>
<li>grid-auto-flow<ul>
<li>划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格</li>
<li>默认值row，先行后列；column，先列后行；<code>row dense</code>表示”先行后列”，并且尽可能紧密填满，尽量不出现空格；<code>column dense</code>表示”先列后行”，并且尽可能紧密填满，尽量不出现空格</li>
</ul>
</li>
<li>justify-items<ul>
<li>设置<strong>单元格内容</strong>的水平位置（左中右）</li>
<li>start,end,center,stretch(默认值)</li>
</ul>
</li>
<li>align-items<ul>
<li>设置<strong>单元格内容</strong>的垂直位置（上中下）</li>
<li>start,end,center,stretch(默认值)</li>
</ul>
</li>
<li>place-items<ul>
<li>合并简写形式</li>
</ul>
</li>
<li>justify-content<ul>
<li><strong>整个内容区域</strong>在容器里面的水平位置（左中右）</li>
<li>start,end,center,stretch,space-around,space-between,space-evenly(项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔)</li>
</ul>
</li>
<li>align-content<ul>
<li><strong>整个内容区域</strong>在容器里面的垂直位置（上中下）</li>
<li>属性值一样</li>
</ul>
</li>
<li>place-content<ul>
<li>上面的合并形式</li>
</ul>
</li>
<li>grid-auto-columns</li>
<li>grid-auto-rows</li>
<li>grid-template<ul>
<li><code>grid-template-columns</code>、<code>grid-template-rows</code>和<code>grid-template-areas</code>这三个属性的合并简写形式</li>
</ul>
</li>
<li>grid<ul>
<li><code>grid-template-rows</code>、<code>grid-template-columns</code>、<code>grid-template-areas</code>、 <code>grid-auto-rows</code>、<code>grid-auto-columns</code>、<code>grid-auto-flow</code>这六个属性的合并简写形式</li>
</ul>
</li>
</ul>
<h3 id="子项-1"><a href="#子项-1" class="headerlink" title="子项"></a>子项</h3><ul>
<li>grid-column-start</li>
<li>grid-column-end</li>
<li>grid-row-start</li>
<li>grid-row-end<ul>
<li>指定项目位置，属性值是第几条边框线</li>
</ul>
</li>
<li>grid-column<ul>
<li><code>grid-column-start</code>和<code>grid-column-end</code>的合并简写形式</li>
<li>中间加<code>/</code>分隔开</li>
</ul>
</li>
<li>gird-row<ul>
<li><code>grid-row-start</code>属性和<code>grid-row-end</code>的合并简写形式</li>
<li>中间加<code>/</code></li>
</ul>
</li>
<li>grid-area<ul>
<li>指定项目放在哪一个区域，和容器属性值grid-template-area搭配</li>
<li>还可用作<code>grid-row-start</code>、<code>grid-column-start</code>、<code>grid-row-end</code>、<code>grid-column-end</code>的合并简写形式<ul>
<li>中间加<code>/</code></li>
</ul>
</li>
</ul>
</li>
<li>justify-self<ul>
<li>跟<code>justify-items</code>属性的用法完全一致，但只作用于单个项目</li>
</ul>
</li>
<li>align-self<ul>
<li>跟<code>align-items</code>属性的用法完全一致，也是只作用于单个项目</li>
</ul>
</li>
<li>place-self<ul>
<li><code>align-self</code>属性和<code>justify-self</code>属性的合并简写形式</li>
</ul>
</li>
</ul>
<h2 id="CSS求值过程"><a href="#CSS求值过程" class="headerlink" title="CSS求值过程"></a>CSS求值过程</h2><p><img src="/images/CSS%E5%9F%BA%E7%A1%80/value.svg" alt="value"></p>
<h2 id="常问面经"><a href="#常问面经" class="headerlink" title="常问面经"></a>常问面经</h2><h3 id="隐藏元素方法"><a href="#隐藏元素方法" class="headerlink" title="隐藏元素方法"></a>隐藏元素方法</h3><ul>
<li>display:none<ul>
<li>渲染树上直接移除，不占据任何空间</li>
<li>产生回流和重绘</li>
</ul>
</li>
<li>visibility:hidden<ul>
<li>仍然在渲染树中，占据空间依然存在</li>
<li>只产生重绘</li>
<li>子元素设置visibility：visible，可以让子孙节点显示</li>
</ul>
</li>
<li>opacity:0</li>
<li>position:absolute，将它移出屏幕</li>
<li>z-index:负值</li>
<li>transform:scale(0,0)<ul>
<li>元素缩小到0，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li>
</ul>
</li>
</ul>
<h3 id="单位区别"><a href="#单位区别" class="headerlink" title="单位区别"></a>单位区别</h3><ul>
<li>px为绝对像素<ul>
<li>我们写的是逻辑像素，实际测的是物理像素</li>
<li>图片像素&gt;物理像素，才不会失真</li>
</ul>
</li>
<li>em相对长度，是相对父元素</li>
<li>rem相对长度，是相对根元素</li>
<li>%，是相对父元素的百分之几</li>
<li>vh、vw是相对视口</li>
<li>vmin，vw和vh中较小值</li>
<li>vmax，vw和vh中较大值</li>
</ul>
<h3 id="如何判断元素是否在可视区域"><a href="#如何判断元素是否在可视区域" class="headerlink" title="如何判断元素是否在可视区域"></a>如何判断元素是否在可视区域</h3><h3 id="如何做适配"><a href="#如何做适配" class="headerlink" title="如何做适配"></a>如何做适配</h3><ul>
<li>使用CSS媒体查询</li>
<li>使用相对单位</li>
</ul>
<h2 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h2><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><ul>
<li><code>#</code></li>
<li><code>rgb()</code></li>
<li><code>hsl()</code><ul>
<li>色相</li>
<li>饱和度<ul>
<li>0-100%</li>
</ul>
</li>
<li>亮度<ul>
<li>0-100%</li>
</ul>
</li>
</ul>
</li>
<li>关键字</li>
<li><code>rgba</code><ul>
<li>a是透明度，0是完全不透明</li>
</ul>
</li>
<li><code>hsla</code></li>
</ul>
<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><ul>
<li><p><code>font-family</code></p>
<ul>
<li><p>可以设定多个字体，用逗号隔开，从左到右逐个匹配，匹配到就使用，不再向后匹配</p>
</li>
<li><p>字体列表最后要使用通用字体族</p>
</li>
<li><p>英文字体要放在中文字体前面</p>
<ul>
<li>因为，中文一般包含了英文字体，中文字体放前面，一般都被匹配了，那么放在后面的英文字体就匹配不了英文字体</li>
</ul>
</li>
</ul>
</li>
<li><p>Web font</p>
<ul>
<li>从网络加载资源</li>
</ul>
</li>
<li><p><code>font-size</code></p>
<ul>
<li>关键字</li>
<li><code>px</code></li>
<li><code>em</code>、<code>rem</code></li>
<li><code>%</code></li>
</ul>
</li>
<li><p><code>font-weight</code></p>
<ul>
<li>关键字<ul>
<li><code>normal</code>（400）</li>
<li><code>bold</code>（700）</li>
</ul>
</li>
<li>直接设置数值<ul>
<li>有时候系统没有那么多对应数值的font-weight字体，所以，一般都是设成400或者700，以适应所有系统</li>
</ul>
</li>
</ul>
</li>
<li><p><code>line-height</code></p>
<ul>
<li>行高</li>
<li>数值带单位</li>
<li>数值不带单位<ul>
<li>数值乘以font-size值</li>
</ul>
</li>
</ul>
</li>
<li><p><code>font-(style weight size/height family)</code></p>
</li>
<li><p><code>text-align</code></p>
<ul>
<li><code>left</code></li>
<li><code>right</code></li>
<li><code>center</code></li>
<li><code>justify</code><ul>
<li>两端对齐</li>
</ul>
</li>
</ul>
</li>
<li><p><code>spacing</code></p>
<ul>
<li><code>letter-spacing</code></li>
<li><code>word-spacing</code></li>
</ul>
</li>
<li><p><code>text-indent</code></p>
<ul>
<li>文字缩进</li>
<li>可正可负</li>
</ul>
</li>
<li><p><code>text-decoration</code></p>
</li>
<li><p><code>white-space</code></p>
</li>
</ul>
<p><code>overflow</code></p>
<ul>
<li><code>visible</code><ul>
<li>溢出</li>
</ul>
</li>
<li><code>hidden</code></li>
<li><code>scroll</code></li>
</ul>
]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>Document</title>
    <url>/2022/01/22/Document/</url>
    <content><![CDATA[<h2 id="浏览器环境和规格"><a href="#浏览器环境和规格" class="headerlink" title="浏览器环境和规格"></a>浏览器环境和规格</h2><p>在浏览器中，window有两种角色</p>
<ul>
<li>Javascript代码的全局对象</li>
<li>代表浏览器窗口，并提供控制它的方法</li>
</ul>
<p>document 对象是页面的主要“入口点”。我们可以使用它来更改或创建页面上的任何内容。</p>
<span id="more"></span>

<h2 id="DOM树"><a href="#DOM树" class="headerlink" title="DOM树"></a>DOM树</h2><p>每个树的节点都是一个对象，一共12种，通常用到4种</p>
<ul>
<li>document——DOM的入口点</li>
<li>元素节点——HTML标签，并形成文档结构</li>
<li>文本节点</li>
<li>注释</li>
</ul>
<h2 id="遍历DOM"><a href="#遍历DOM" class="headerlink" title="遍历DOM"></a>遍历DOM</h2><h3 id="对象间链接"><a href="#对象间链接" class="headerlink" title="对象间链接"></a>对象间链接</h3><blockquote>
<p>对所有节点，是包含元素节点，文本节点，注释等</p>
</blockquote>
<p><img src="/2022/01/22/Document/fd565c1de6fcacaa600a120b4d23797.png" alt="fd565c1de6fcacaa600a120b4d23797"></p>
<p>顶层树节点可以直接获取</p>
<ul>
<li><code>document.documentElement</code>——<code>&lt;html&gt;</code></li>
<li><code>document.body</code></li>
<li><code>document.head</code></li>
</ul>
<p>两个术语</p>
<ul>
<li>子节点——直系的子元素<ul>
<li>childNodes列出<strong>所有</strong>子节点，<strong>包括文本节点</strong><ul>
<li>返回的不是数组，而是集合，一个类数组的可迭代对象，可以用Array.from方法用它来创建一个”真“数组，使得能使用数组的方法</li>
<li>DOM集合是只读的，</li>
<li>是实时的——例如先取得<code>elem.childNodes</code>的引用，而后修改DOM，那么节点的更新会自动出现在集合中</li>
</ul>
</li>
<li>firstChild访问第一个子元素</li>
<li>lastChild访问最后一个子元素</li>
</ul>
</li>
<li>子孙元素——嵌套在给定元素中所有的元素</li>
</ul>
<p>兄弟节点</p>
<ul>
<li>nextSibling下一个兄弟节点</li>
<li>previousSibling上一个兄弟节点</li>
</ul>
<p>父节点</p>
<ul>
<li>parentNode</li>
</ul>
<h3 id="元素节点导航链接"><a href="#元素节点导航链接" class="headerlink" title="元素节点导航链接"></a>元素节点导航链接</h3><p><img src="/2022/01/22/Document/595929645f562545efc0a04edc7fe05.png" alt="595929645f562545efc0a04edc7fe05"></p>
<ul>
<li>children——元素节点的子代的节点</li>
<li>firstElementChild</li>
<li>lastElementChild</li>
<li>previousElementSibling</li>
<li>nextElementSibling</li>
<li>parentElement</li>
</ul>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><ul>
<li>table.rows——<code>&lt;tr&gt;</code>元素的<strong>集合</strong><ul>
<li>tr.cells<ul>
<li>给定<code>&lt;tr&gt;</code>中的<code>&lt;td&gt;</code>和<code>&lt;th&gt;</code>单元格的集合</li>
</ul>
</li>
<li>tr.sectionRowIndex<ul>
<li>给定的<code>&lt;tr&gt;</code>在封闭的<code>&lt;thead&gt;/&lt;tbody&gt;/&lt;tfoot&gt;</code>中的位置（索引）。</li>
</ul>
</li>
<li>tr.rowIndex<ul>
<li>整个表格<code>&lt;tr&gt;</code>的编号</li>
</ul>
</li>
</ul>
</li>
<li>table.caption</li>
<li>table.tHead</li>
<li>table.tFoot</li>
<li>table.tBodies——<code>&lt;tbody&gt;</code>元素的集合</li>
<li><code>&lt;td&gt;</code>和<code>&lt;th&gt;</code><ul>
<li>td.cellIndex在封闭的<code>&lt;tr&gt;</code>中单元格的编号</li>
</ul>
</li>
</ul>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><ol>
<li>getElement*<ul>
<li>document.getElementById(id)</li>
</ul>
</li>
<li>querySelector*<ul>
<li>elem.querySelectorAll(CSS)<ul>
<li>返回 elem 中与给定 CSS 选择器匹配的<strong>所有</strong>元素</li>
<li>静态集合，像固定的数组</li>
</ul>
</li>
<li>elem.querySelector(CSS)<ul>
<li>返回给定 CSS 选择器的<strong>第一个</strong>元素</li>
</ul>
</li>
</ul>
</li>
<li>elem.matches(CSS)<ul>
<li>检查 elem 是否与给定的 CSS 选择器匹配。它返回 true 或 false</li>
</ul>
</li>
<li>elem.closest(CSS)<ul>
<li>查找与 CSS 选择器匹配的<strong>最近的祖先</strong></li>
</ul>
</li>
<li>“getElementsBy*”方法，返回的都是<strong>实时的集合</strong>，始终反映的是文档的当前状态<ul>
<li>elem.getElementsByTagName(tag)</li>
<li>elem.getElementsByClassName(className)</li>
<li>document.getElementsByName(name)</li>
</ul>
</li>
<li>elemA.contains(elemB)<ul>
<li>elemB 在 elemA 内或者 elemA==elemB就返回true</li>
</ul>
</li>
</ol>
<h2 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h2><ul>
<li>innerHTML<ul>
<li>仅对元素节点有效<ul>
<li>文本节点、注释节点用<code>data</code>属性获取内容</li>
</ul>
</li>
<li>+= 是会重写，先抹除原先内容，再把原先内容和附加内容结合，赋值过去<ul>
<li>因此所有的图片和其他资源都将重写加载</li>
</ul>
</li>
</ul>
</li>
<li>outerHTML<ul>
<li>写入 outerHTML 不会改变元素。而是在 DOM 中替换它<ul>
<li>写入后，DOM会显示新写入的，但打印出来却是旧的值</li>
</ul>
</li>
<li>outerHTML 赋值不会修改 DOM 元素，而是将其从 DOM 中删除并在其位置插入新的 HTML。</li>
</ul>
</li>
<li>textContent<ul>
<li>只返回文本，就像所有<code>tag</code>都被剪掉了一样</li>
<li>写入比innerHTML安全一些，因为，innerHTML写入的内容会作为html插入，而textContent只当成文本插入</li>
</ul>
</li>
<li>hidden<ul>
<li>设置为true与CSS中，<code>display: none</code>做着相同的事情</li>
</ul>
</li>
</ul>
<p>大多数标准 HTML 特性（attribute）都具有相应的 DOM 属性。</p>
<h2 id="特性-写在-HTML-中的内容-和属性-DOM-对象中的内容"><a href="#特性-写在-HTML-中的内容-和属性-DOM-对象中的内容" class="headerlink" title="特性(写在 HTML 中的内容)和属性( DOM 对象中的内容)"></a>特性(写在 HTML 中的内容)和属性( DOM 对象中的内容)</h2><blockquote>
<p>当浏览器加载页面时，它会“读取”（或者称之为：“解析”）HTML 并从中生成 DOM 对象。对于元素节点，大多数标准的 HTML 特性（attributes）会自动变成 DOM 对象的属性（properties）</p>
<p>但特性—属性映射并不是一一对应的</p>
</blockquote>
<h3 id="DOM属性"><a href="#DOM属性" class="headerlink" title="DOM属性"></a>DOM属性</h3><p>DOM节点是常规的Javascript的对象</p>
<ul>
<li>大小写敏感</li>
<li>可以设多种值</li>
</ul>
<h2 id="HTML特性"><a href="#HTML特性" class="headerlink" title="HTML特性"></a>HTML特性</h2><ul>
<li>当浏览器解析 HTML 文本，并根据标签创建 DOM 对象时，浏览器会辨别<strong>标准的</strong>特性并以此创建 DOM 属性。而<strong>非标准的</strong>就没有相对应的 DOM 属性，会变成了<code>undefined</code></li>
<li>大小写不敏感</li>
<li>值总是字符串类型</li>
</ul>
<p>所有特性（标准的非标准的）都可以通过使用以下方法进行访问：</p>
<ul>
<li>elem.hasAttribute(name) — 检查特性是否存在</li>
<li>elem.getAttribute(name) — 获取这个特性值</li>
<li>elem.setAttribute(name, value) — 设置这个特性值</li>
<li>elem.removeAttribute(name) — 移除这个特性。</li>
</ul>
<h3 id="属性-特性同步"><a href="#属性-特性同步" class="headerlink" title="属性-特性同步"></a>属性-特性同步</h3><p>当一个标准的特性被改变，对应的属性也会自动更新，（除了几个特例）反之亦然</p>
<ul>
<li>例外：如<code>input.value</code>只能从特性同步到属性</li>
</ul>
<h3 id="非标准特性dataset"><a href="#非标准特性dataset" class="headerlink" title="非标准特性dataset"></a>非标准特性dataset</h3><blockquote>
<p>非标准的特性常常用于将自定义的数据从 HTML 传递到 JavaScript，或者用于为 JavaScript “标记” HTML 元素</p>
</blockquote>
<p>为了避免冲突，所有以 <code>data-</code> 开头的特性均被保留供程序员使用。它们可在 dataset 属性中使用。</p>
<p>用法：</p>
<ul>
<li>如果一个 elem 有一个名为 <code>data-about</code> 的特性，那么可以通过 <code>elem.dataset.about</code> 取到它</li>
<li>多词特性可以以驼峰式进行调用</li>
</ul>
<h2 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a>修改文档</h2><h3 id="创建一个元素"><a href="#创建一个元素" class="headerlink" title="创建一个元素"></a>创建一个元素</h3><ul>
<li><code>document.createElement(tag)</code><ul>
<li>元素节点</li>
</ul>
</li>
<li><code>document.createTextNode(text)</code><ul>
<li>文本节点</li>
</ul>
</li>
</ul>
<h3 id="添加类"><a href="#添加类" class="headerlink" title="添加类"></a>添加类</h3><ul>
<li>className</li>
</ul>
<h3 id="填充消息"><a href="#填充消息" class="headerlink" title="填充消息"></a>填充消息</h3><ul>
<li>innerHTML</li>
</ul>
<h3 id="插入方法"><a href="#插入方法" class="headerlink" title="插入方法"></a>插入方法</h3><p>字符串被以一种安全的方式插入到页面中，就像 <code>elem.textContent </code>所做的一样——不会被当成html插入，只当成文本</p>
<ul>
<li>node.append(nodes or strings)<ul>
<li>在 node <strong>末尾</strong>插入节点或字符串</li>
</ul>
</li>
<li>node.prepend()<ul>
<li>在node<strong>开头</strong>插入节点或字符串</li>
</ul>
</li>
<li>node.before()<ul>
<li>在node<strong>前面</strong>插入节点或字符串</li>
</ul>
</li>
<li>node.after()<ul>
<li>在node<strong>后面</strong>插入节点或字符串</li>
</ul>
</li>
<li>node.replaceWIth()<ul>
<li>将node替换给定的节点或字符串</li>
</ul>
</li>
</ul>
<ul>
<li><p>elem.insertAdjacentHTML(where, html) </p>
<ul>
<li>内容作为 HTML 代码插入，如同innerHTML</li>
<li>where如下面的值</li>
</ul>
<p><img src="/2022/01/22/Document/image-20220313160632338.png" alt="image-20220313160632338"></p>
</li>
</ul>
<h3 id="节点移除"><a href="#节点移除" class="headerlink" title="节点移除"></a>节点移除</h3><ul>
<li>node.remove()</li>
</ul>
<h3 id="克隆节点"><a href="#克隆节点" class="headerlink" title="克隆节点"></a>克隆节点</h3><ul>
<li>cloneNode(true/false)<ul>
<li>true为深克隆，具有所有特性 （attribute）和子元素</li>
<li>false，则不克隆子元素</li>
</ul>
</li>
</ul>
<h3 id="DocumentFragment"><a href="#DocumentFragment" class="headerlink" title="DocumentFragment"></a>DocumentFragment</h3><p>可以理解为容器</p>
<h2 id="样式和类"><a href="#样式和类" class="headerlink" title="样式和类"></a>样式和类</h2><h3 id="className"><a href="#className" class="headerlink" title="className"></a>className</h3><p>它将替换类中的整个字符串</p>
<h3 id="classList"><a href="#classList" class="headerlink" title="classList"></a>classList</h3><p>可迭代</p>
<p>方法</p>
<ul>
<li>add()<ul>
<li>添加一个类</li>
</ul>
</li>
<li>remove()<ul>
<li>移除一个类</li>
</ul>
</li>
<li>toggle()<ul>
<li>如果类不存在就添加类，存在就移除它</li>
</ul>
</li>
</ul>
<h3 id="重置样式属性"><a href="#重置样式属性" class="headerlink" title="重置样式属性"></a>重置样式属性</h3><p>设为空字符</p>
<p><code>elem.style.* = &quot;&quot;</code></p>
<p>使用 style.* 来对各个样式属性进行赋值时，需要有单位，且不能一下子设置所有属性，因为 div.style 是一个对象，并且它是只读的，设置完整属性可用<code>style.cssText</code></p>
<h3 id="计算样式getComputedStyle"><a href="#计算样式getComputedStyle" class="headerlink" title="计算样式getComputedStyle"></a>计算样式getComputedStyle</h3><p><code>getComputedStyle(element, [pseudo])</code></p>
<ul>
<li>element <ul>
<li>需要被读取样式值的元素</li>
</ul>
</li>
<li>pseudo <ul>
<li>伪元素（如果需要），例如 ::before 。空字符串或无参数则意味着元素本身。</li>
</ul>
</li>
</ul>
<h2 id="元素大小和滚动"><a href="#元素大小和滚动" class="headerlink" title="元素大小和滚动"></a>元素大小和滚动</h2><p>几何属性，这些属性的值在技术上讲是数字，但这些数字其实是“像素（pixel）”</p>
<p><img src="/2022/01/22/Document/image-20220313164146836.png" alt="image-20220313164146836"></p>
<ul>
<li>offsetParent 是最接近的祖先<ul>
<li>最近祖先为下列之一<ul>
<li>CSS 定位的（ position 为 absolute ， relative 或 fixed ）</li>
<li>或<code>&lt;td&gt;,&lt;th&gt;,&lt;table&gt;</code></li>
<li>或<code>&lt;body&gt;</code></li>
</ul>
</li>
<li>值有可能为null<ul>
<li>未显示的元素（ display:none 或者不在文档中）</li>
<li>对于<code>&lt;body&gt;,&lt;html&gt;</code></li>
<li>对于带有position：fixed元素</li>
</ul>
</li>
</ul>
</li>
<li>属性 offsetLeft/offsetTop 提供相对于 offsetParent 左上角的 x/y 坐标</li>
<li>offsetWidth/offsetHeight 是完整边框<ul>
<li>content width/height + 2个padding width/height + 2个margin width/height</li>
</ul>
</li>
<li>对于未显示的元素，几何属性为 0/null<ul>
<li>用几何属性来检查一个元素是否被隐藏</li>
</ul>
</li>
<li>clientTop<ul>
<li>上边框宽度</li>
</ul>
</li>
<li>clientLeft<ul>
<li>左边框宽度</li>
</ul>
</li>
<li>clientWidth/clientHeight<ul>
<li>元素边框内区域的大小——content width/height + 2个 padding width/height</li>
</ul>
</li>
<li>scrollWidth/scrollHeight<ul>
<li>就像 clientWidth/clientHeight ，但它们还包括滚动出（隐藏）的部分</li>
</ul>
</li>
<li>scrollLeft/scrollTop<ul>
<li>是元素的隐藏、滚动部分的 width/height</li>
</ul>
</li>
</ul>
<h3 id="使用几何属性的原因"><a href="#使用几何属性的原因" class="headerlink" title="使用几何属性的原因"></a>使用几何属性的原因</h3><ol>
<li>首先，CSS width/height 取决于另一个属性： box-sizing ，它定义了“什么是” CSS 宽度和高度。出于 CSS 的目的而对 box-sizing 进行的更改可能会破坏 此类 JavaScript 操作。</li>
<li>其次，CSS 的 width/height 可能是 auto ，例如内联（inline）元素。但在 JavaScript 中，我们需要 一个确切的 px 大小，以便我们在计算中使用它。</li>
</ol>
<h2 id="Window大小和滚动"><a href="#Window大小和滚动" class="headerlink" title="Window大小和滚动"></a>Window大小和滚动</h2><p>使用 document.documentElement 的 clientWidth/clientHeight返回文档可见部分，这个值不包括滚动条。</p>
<h3 id="获得当前滚动"><a href="#获得当前滚动" class="headerlink" title="获得当前滚动"></a>获得当前滚动</h3><ul>
<li>scrollLeft/scrollTop </li>
</ul>
<h3 id="调整滚动位置"><a href="#调整滚动位置" class="headerlink" title="调整滚动位置"></a>调整滚动位置</h3><ul>
<li>方法 scrollBy(x,y) 将页面滚动至 相对于当前位置的 (x, y) 位置</li>
<li>方法 scrollTo(pageX,pageY) 将页面滚动至绝对坐标，使得可见部分的左上角具有相对于文档左上角的坐标 (pageX, pageY) 。就像设置了 scrollLeft/scrollTop 一样。</li>
</ul>
<h3 id="禁止滚动"><a href="#禁止滚动" class="headerlink" title="禁止滚动"></a>禁止滚动</h3><p>设置overflow：hidden</p>
<h2 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h2><h3 id="元素坐标-getBoundingClinetRect"><a href="#元素坐标-getBoundingClinetRect" class="headerlink" title="元素坐标 getBoundingClinetRect()"></a>元素坐标 getBoundingClinetRect()</h3><p><img src="/2022/01/22/Document/image-20220313171141878.png" alt="image-20220313171141878"></p>
<p>页面上的任何点都有坐标：</p>
<ul>
<li>相对于窗口的坐标 — elem.getBoundingClientRect() 。</li>
<li>相对于文档的坐标 — elem.getBoundingClientRect() 加上当前页面滚动。</li>
</ul>
]]></content>
      <categories>
        <category>现代Javascript教程</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML中的Javascript</title>
    <url>/2022/01/06/HTML%E4%B8%AD%E7%9A%84Javascript/</url>
    <content><![CDATA[<h2 id="lt-script-gt-元素"><a href="#lt-script-gt-元素" class="headerlink" title="&lt;script&gt;元素"></a><code>&lt;script&gt;</code>元素</h2><ul>
<li><p>async</p>
</li>
<li><p>crossorigin</p>
<blockquote>
<p>配置相关CORS设置</p>
</blockquote>
<ul>
<li>anonymous</li>
<li>use-credentials</li>
</ul>
</li>
<li><p>defer</p>
</li>
<li><p>intergrity</p>
<blockquote>
<p>允许比对接收到的资源和指定的加密签名以验证子资源完整性，如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行，用于确保内容分发网络（CDN，ContentDeliveryNetwork）不会提供恶意内容</p>
</blockquote>
</li>
<li><p>src</p>
<ul>
<li>会忽略行内脚本</li>
<li>不会受浏览器的同源策略限制，但返回并被执行的JavaScript则受限制</li>
</ul>
</li>
<li><p>type</p>
<ul>
<li><code>text/javascript</code></li>
<li><code>module</code><ul>
<li>会被当成ES6模块</li>
<li>脚本加载解析过程与defer相同</li>
</ul>
</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="行内脚本与外部脚本的比较"><a href="#行内脚本与外部脚本的比较" class="headerlink" title="行内脚本与外部脚本的比较"></a>行内脚本与外部脚本的比较</h2><ol>
<li><p>行内脚本</p>
<p>下载和执行会阻塞<code>HTML</code>的解析</p>
</li>
<li><p>外部脚本</p>
<ul>
<li>不加<code>async</code>和<code>defer</code><ul>
<li>与行内脚本一样，下载和执行会阻塞HTML的解析</li>
</ul>
</li>
<li><code>defer</code><ul>
<li>下载不会阻塞，执行放在最后，执行会有先后顺序，且会在<code>DOMContentLoaded</code>事件之前执行</li>
</ul>
</li>
<li><code>async</code><ul>
<li>下载不会阻塞，下载完后会马上执行，且执行并不保证能按照它们出现的次序执行</li>
<li>异步脚本保证会在页面的<code>load</code>事件前执行，但可能会在<code>DOMContentLoaded</code>之前或之后</li>
</ul>
</li>
</ul>
</li>
<li><p>动态加载脚本</p>
<p>通过<code>document.createElement</code>动态加载，会异步加载，相当于添加<code>async</code>属性</p>
</li>
</ol>
<p>建议都使用外部脚本，原因：</p>
<ul>
<li>可维护性</li>
<li>缓存<ul>
<li>浏览器会根据特定的设置缓存所有外部链接的JavaScript文件，如果两个页面都用到同一个文件，则该文件只需下载一次。</li>
</ul>
</li>
</ul>
<h2 id="文档模式对Javascript有什么影响"><a href="#文档模式对Javascript有什么影响" class="headerlink" title="文档模式对Javascript有什么影响"></a>文档模式对Javascript有什么影响</h2><p>可以使用<code>doctype</code>切换文档模式，共有三种文档模块</p>
<ol>
<li>混杂模式</li>
<li>标准模式</li>
<li>准标准模式</li>
</ol>
<p>前两种主要区别体现在通过CSS渲染的内容方面，后两种主要区别在于如何对待图片元素周围的空白（在表格中使用图片时最明显）。</p>
<h2 id="确保Javascript不可用时的用户体验"><a href="#确保Javascript不可用时的用户体验" class="headerlink" title="确保Javascript不可用时的用户体验"></a>确保Javascript不可用时的用户体验</h2><p>使用<code>&lt;noscript&gt;</code>元素，在JavaScript被禁用或不支持时，元素里面的内容会呈现出来。<code>&lt;noscript&gt;</code>元素可以包含任何可以出现在<code>&lt;body&gt;</code>中的HTML元素。</p>
]]></content>
      <categories>
        <category>Javascript高级程序设计</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML基础</title>
    <url>/2022/01/18/HTML%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="前端关注点"><a href="#前端关注点" class="headerlink" title="前端关注点"></a>前端关注点</h2><ul>
<li>解决GUI人机交互问题</li>
<li>跨终端<ul>
<li>PC/移动浏览器</li>
<li>客户端/小程序</li>
<li>VR/AR等</li>
</ul>
</li>
<li>Web技术栈</li>
</ul>
<span id="more"></span>

<h2 id="前端技术栈"><a href="#前端技术栈" class="headerlink" title="前端技术栈"></a>前端技术栈</h2><p>服务器端通过网络协议与客户端交流</p>
<p>而前端主要指下面三个部分</p>
<ul>
<li>Javascript（行为）</li>
<li>CSS（样式）</li>
<li>HTML（内容）</li>
</ul>
<h2 id="关注方面"><a href="#关注方面" class="headerlink" title="关注方面"></a>关注方面</h2><ul>
<li><p>功能</p>
<ul>
<li>首要部分</li>
</ul>
</li>
<li><p>美观</p>
</li>
<li><p>无障碍</p>
</li>
<li><p>安全</p>
<ul>
<li>用户数据安全</li>
</ul>
</li>
<li><p>性能</p>
</li>
<li><p>兼容性</p>
<ul>
<li>跨端</li>
</ul>
</li>
<li><p>体验</p>
</li>
</ul>
<h2 id="HTML是什么"><a href="#HTML是什么" class="headerlink" title="HTML是什么"></a>HTML是什么</h2><blockquote>
<p>HyperText Markup Language</p>
</blockquote>
<ul>
<li>HyperText<ul>
<li>图片、标题、链接、表格</li>
</ul>
</li>
<li>Markup Language<ul>
<li>标签</li>
</ul>
</li>
</ul>
<h3 id="DOCTYPE的作⽤"><a href="#DOCTYPE的作⽤" class="headerlink" title="DOCTYPE的作⽤"></a>DOCTYPE的作⽤</h3><p>决定HTML使用哪个版本，并且浏览器根据这个来决定使用哪一种的渲染模式，有两种渲染模式</p>
<ul>
<li>标准模式<ul>
<li>按照最佳的相关规范进行渲染</li>
</ul>
</li>
<li>怪异模式<ul>
<li>一种比较宽松的向后兼容的方式显示</li>
</ul>
</li>
</ul>
<p>浏览器拿到HTML后，将其解析为DOM树</p>
<h2 id="HTML语法"><a href="#HTML语法" class="headerlink" title="HTML语法"></a>HTML语法</h2><ul>
<li>标签和属性不区分大小写</li>
<li>空标签可以不闭合</li>
<li>属性值推荐用引号包裹</li>
<li>某些属性值可以省略</li>
</ul>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul>
<li>ol、li</li>
<li>ul、li</li>
<li>dl、dt、dd<ul>
<li>定义列表</li>
<li>定义标题</li>
<li>定义描述</li>
</ul>
</li>
</ul>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul>
<li>a<ul>
<li>href<ul>
<li>跳转链接位置</li>
</ul>
</li>
<li>target</li>
</ul>
</li>
<li>img<ul>
<li>src</li>
<li>alt</li>
</ul>
</li>
<li>audio<ul>
<li>src</li>
<li>controls<ul>
<li>播放控件</li>
</ul>
</li>
</ul>
</li>
<li>video<ul>
<li>src</li>
<li>controls</li>
</ul>
</li>
</ul>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><ul>
<li>input<ul>
<li>placeholder</li>
<li>type<ul>
<li>range</li>
<li>number</li>
<li>date</li>
<li>checkbox</li>
<li>radio<ul>
<li>name属性设置相同属性值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>textarea<ul>
<li>多行输入</li>
</ul>
</li>
<li>select option</li>
<li>datalist option<ul>
<li>提示补全</li>
</ul>
</li>
</ul>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul>
<li>blockquote</li>
<li>长引用<ul>
<li>cite属性，引用来源</li>
</ul>
</li>
<li>cite<ul>
<li>短引用</li>
<li>作品、名字</li>
</ul>
</li>
<li>q<ul>
<li>短引用</li>
<li>一句话</li>
</ul>
</li>
<li>code<ul>
<li>代码引用</li>
</ul>
</li>
</ul>
<h3 id="文本标签"><a href="#文本标签" class="headerlink" title="文本标签"></a>文本标签</h3><ul>
<li>strong<ul>
<li>表示事情非常重要、严重</li>
</ul>
</li>
<li>em<ul>
<li>语气上的强调</li>
</ul>
</li>
</ul>
<h3 id="内容划分"><a href="#内容划分" class="headerlink" title="内容划分"></a>内容划分</h3><ul>
<li>header<ul>
<li>nav</li>
</ul>
</li>
<li>main<ul>
<li>artticle</li>
</ul>
</li>
<li>aside</li>
<li>footer</li>
</ul>
<h2 id="语义化"><a href="#语义化" class="headerlink" title="语义化"></a>语义化</h2><p>元素、属性、属性值都拥有某些含义</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>开发者<ul>
<li>代码可读性</li>
<li>可维护性</li>
</ul>
</li>
<li>浏览器</li>
<li>搜索引擎<ul>
<li>提取关键词、排序</li>
<li>搜索引擎优化</li>
</ul>
</li>
<li>屏幕阅读器<ul>
<li>提升无障碍性</li>
</ul>
</li>
</ul>
<h3 id="如何做到语义化"><a href="#如何做到语义化" class="headerlink" title="如何做到语义化"></a>如何做到语义化</h3><ul>
<li>了解标签、属性含义</li>
<li>思考什么标签最适合描述这个内容</li>
</ul>
]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>React</title>
    <url>/2022/01/21/React/</url>
    <content><![CDATA[<h2 id="历史和应用"><a href="#历史和应用" class="headerlink" title="历史和应用"></a>历史和应用</h2><ul>
<li>一个东西的出现，往往是因为在某个历史阶段人们产生了某些需求</li>
<li>新的东西出现肯定是因为之前的东西不好用</li>
</ul>
<span id="more"></span>

<h3 id="React的原型：FaxJS"><a href="#React的原型：FaxJS" class="headerlink" title="React的原型：FaxJS"></a>React的原型：FaxJS</h3><ul>
<li>客户端或服务端渲染</li>
<li>响应式<ul>
<li>状态更新-&gt;UI更新</li>
</ul>
</li>
<li>性能好</li>
<li>结构化</li>
</ul>
<p><a href="https://www.youtube.com/watch?v=GW0rj4sNH2w">Tom Occhino and Jordan Walke: JS Apps at Facebook</a></p>
<h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>例子：苹果官网手机价格变化</p>
<h3 id="UI编程痛点"><a href="#UI编程痛点" class="headerlink" title="UI编程痛点"></a>UI编程痛点</h3><ul>
<li>状态更新，UI不会自动更新，需要手动调用DOM进行更新<ul>
<li>需改良：状态更新，UI自动更新</li>
</ul>
</li>
<li>欠缺基本的代码层面的封装和隔离，代码层面没有组件化<ul>
<li>需改良：前端代码组件化，可复用，可封装</li>
</ul>
</li>
<li>UI之间的数据依赖关系需要手动维护，如果依赖链路长，则会遇到回调地狱<ul>
<li>需改良：状态之间互相依赖关系，只需声明即可</li>
</ul>
</li>
</ul>
<p>例子：火警，烧水</p>
<h3 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h3><ol>
<li>事件</li>
<li>执行既定的回调</li>
<li>状态变更</li>
<li>UI更新</li>
</ol>
<p>回到苹果官网例子，对页面进行组件化划分</p>
<ul>
<li>组件是 组件的组合/原子组件</li>
<li>组件内拥有状态，外部不可见</li>
<li>父组件可将状态传入组件内部</li>
</ul>
<h3 id="状态归属问题"><a href="#状态归属问题" class="headerlink" title="状态归属问题"></a>状态归属问题</h3><ul>
<li>确定“数据”应该放在哪个组件里保存</li>
<li>状态归属于两个节点向上寻找到最近的祖宗节点<ul>
<li>又会带来一个问题，数据有时经常性放在很上层的组件上，这会失去了组件复用的初衷</li>
<li>子组件如何触发改变上层组件数据的事件？<ul>
<li>通过上层组件传递函数到子组件，子组件再调用此函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ol>
<li>React是单向数据流还是双向数据流<ul>
<li>是单向数据流</li>
<li>父组件能把状态传给子组件，而子组件并不能把状态网上传给父组件，只是单纯的执行了父组件传下来的函数，从而能改变了父组件的状态</li>
</ul>
</li>
<li>如何解决状态不合理上升的问题</li>
<li>组件的状态改变后，如何更新DOM</li>
</ol>
<p>状态应是局部性</p>
<h3 id="组件设计"><a href="#组件设计" class="headerlink" title="组件设计"></a>组件设计</h3><ol>
<li>组件声明了状态和UI的映射</li>
<li>组件有Props/State两种状态<ul>
<li>内部拥有私有状态State</li>
<li>外部能接受Props状态，提供复用性</li>
<li>根据当前State/Props返回一个UI</li>
</ul>
</li>
<li>“组件”可由其他组件拼接而成</li>
</ol>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ol>
<li><p>组件挂载时</p>
<ul>
<li><p><a href="https://zh-hans.reactjs.org/docs/react-component.html#constructor"><strong><code>constructor()</code></strong></a></p>
</li>
<li><p><a href="https://zh-hans.reactjs.org/docs/react-component.html#static-getderivedstatefromprops"><code>static getDerivedStateFromProps()</code></a></p>
</li>
<li><p><a href="https://zh-hans.reactjs.org/docs/react-component.html#render"><strong><code>render()</code></strong></a></p>
</li>
<li><p><a href="https://zh-hans.reactjs.org/docs/react-component.html#componentdidmount"><strong><code>componentDidMount()</code></strong></a></p>
</li>
</ul>
</li>
<li><p>组件更新时</p>
<ul>
<li><a href="https://zh-hans.reactjs.org/docs/react-component.html#static-getderivedstatefromprops"><code>static getDerivedStateFromProps()</code></a></li>
<li><a href="https://zh-hans.reactjs.org/docs/react-component.html#shouldcomponentupdate"><code>shouldComponentUpdate()</code></a></li>
<li><a href="https://zh-hans.reactjs.org/docs/react-component.html#render"><strong><code>render()</code></strong></a></li>
<li><a href="https://zh-hans.reactjs.org/docs/react-component.html#getsnapshotbeforeupdate"><code>getSnapshotBeforeUpdate()</code></a></li>
<li><a href="https://zh-hans.reactjs.org/docs/react-component.html#componentdidupdate"><strong><code>componentDidUpdate()</code></strong></a></li>
</ul>
</li>
<li><p>组件卸载时</p>
<ul>
<li><a href="https://zh-hans.reactjs.org/docs/react-component.html#componentwillunmount"><strong><code>componentWillUnmount()</code></strong></a></li>
</ul>
</li>
</ol>
<h2 id="hooks写法"><a href="#hooks写法" class="headerlink" title="hooks写法"></a>hooks写法</h2><p>副作用</p>
<ul>
<li>改变了外部的东西</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="实现时存在的三个问题"><a href="#实现时存在的三个问题" class="headerlink" title="实现时存在的三个问题"></a>实现时存在的三个问题</h3><ol>
<li>JSX不符合JS标准</li>
<li>返回的JSX发生改变时如何更新DOM</li>
<li>State/Props更新时，要重新触发render函数（render函数就是组件函数）</li>
</ol>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol>
<li>转义JSX</li>
<li>使用虚拟DOM<ul>
<li>虚拟DOM是一种用于和真实DOM同步，而在JS内存中维护的一个对象，它具有和DOM类似的树状结构，并和DOM可以建立一一对应的关系</li>
<li>真实的DOM不是JS内存中的对象，而是浏览器维护的一个状态</li>
</ul>
</li>
<li>diff算法更新DOM<ul>
<li>我们只能通过DOM接口去修改DOM，而不能直接去修改DOM。但是我们可以声明一个变量，和真实DOM有类似结构的变量，每次更新的时候，都生成一个新的虚拟DOM，再使用diff算法去对比新旧虚拟DOM，再去修改真实DOM</li>
</ul>
</li>
</ol>
<p>插入一个问题：既然所有前端框架都是声明式的，那为什么不把声明式直接植入到浏览器中，自带声明式，这样就不用框架了。</p>
<ul>
<li>因为，浏览器自己作为应用平台，不能只提供更高层的东西，因为这样会把浏览器的自由度变得更低了。</li>
</ul>
<h3 id="diff算法核心"><a href="#diff算法核心" class="headerlink" title="diff算法核心"></a>diff算法核心</h3><ol>
<li>不同类型的元素-&gt;替换</li>
<li>同类型的DOM元素-&gt;更新</li>
<li>同类型的组件元素-&gt;递归</li>
</ol>
<p>更新次数少与计算速度快的抉择</p>
<p>用层次遍历，每个节点只遍历一次，时间复杂度<code>O(n^3)</code>降到<code>O(n)</code></p>
<p>出现一个问题：但父组件的状态发生改变，子组件和嵌套的子组件都要去递归的发生改变，其实这样很耗费性能，所以要考虑如何去优化。</p>
<h3 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a>编程思想</h3><ul>
<li>指令式编程<ul>
<li>一步步写清楚</li>
</ul>
</li>
<li>声明式编程<ul>
<li>只需说明你的目的</li>
</ul>
</li>
<li>响应式编程<ul>
<li>是声明式编程的一个类别</li>
<li>不仅像声明式编程一样，还可以自动更新UI</li>
</ul>
</li>
</ul>
<h2 id="状态管理库"><a href="#状态管理库" class="headerlink" title="状态管理库"></a>状态管理库</h2><blockquote>
<p>将状态抽离的UI外部进行统一管理</p>
</blockquote>
<p>问题：假如所有数据都放到外部的Store中，那么会与外部store发生强耦合，可复用性就变差。所以要如何选择哪些状态放到Store，哪些状态只放在自身组件中。</p>
<p>可以把Store看成这样：这个store是多个组件（把这多个组件看成一个大的整体组件）内部的一个state</p>
<h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><p>当前状态，收到外部事件，前一道下一个状态</p>
<h2 id="应用级框架科普"><a href="#应用级框架科普" class="headerlink" title="应用级框架科普"></a>应用级框架科普</h2><ul>
<li>next<ul>
<li>了解一间公司vercel</li>
</ul>
</li>
<li>modernJs<ul>
<li>字节的全栈开发框架</li>
</ul>
</li>
<li>Blitz<ul>
<li>无API思想的全栈开发框架</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>青训营</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>事件简介</title>
    <url>/2022/02/13/%E4%BA%8B%E4%BB%B6%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="常见浏览器事件"><a href="#常见浏览器事件" class="headerlink" title="常见浏览器事件"></a>常见浏览器事件</h2><ol>
<li><p>鼠标</p>
<ul>
<li><p><code>click</code></p>
</li>
<li><p><code>contextmenu</code></p>
</li>
<li><p><code>mouseover/mouseout</code></p>
</li>
<li><p><code>mousedown/mouseup</code></p>
</li>
<li><p><code>mousemove</code></p>
</li>
</ul>
</li>
<li><p>键盘</p>
<ul>
<li>keydown</li>
<li>keyup</li>
</ul>
</li>
<li><p>表单</p>
<ul>
<li>submit</li>
<li>focus</li>
</ul>
</li>
<li><p>Document事件</p>
<ul>
<li>DOMContentLoaded</li>
</ul>
</li>
<li><p>CSS</p>
<ul>
<li>transitionend</li>
</ul>
</li>
</ol>
<span id="more"></span>

<p>移除一个处理程序——赋值为<code>null</code></p>
<p>处理程序中的 this 的值是对应的元素。就是处理程序所在的那个元素</p>
<h3 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener"></a>addEventListener</h3><p><code>element.addEventListener(event, handler[, options]);</code></p>
<ul>
<li>options<ul>
<li><code>once</code> ：如果为 true ，那么会在被触发后自动删除监听器</li>
<li><code>capture</code> ：事件处理的阶段，我们稍后将在 冒泡和捕获 一章中介绍。由于历史原因， options 也可以是 false/true ，它与 {capture: false/true} 相同</li>
<li><code>passive</code> ：如果为 true ，那么处理程序将不会调用 <code>preventDefault() </code><ul>
<li>用途：passive: true 选项告诉浏览器，处理程序不会取消滚动。然后浏览器立即滚动页面以提供最大程度的流畅体验，并通过某种方式处理事件。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="移除处理程序-removeEventListener"><a href="#移除处理程序-removeEventListener" class="headerlink" title="移除处理程序 removeEventListener"></a>移除处理程序 removeEventListener</h3><p>element.removeEventListener(event, handler[, options])</p>
<ul>
<li>handler函数要与之前添加事件函数是同一个</li>
</ul>
<h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p>当事件发生时，浏览器会创建一个<code>event</code> 对象，将详细信息放入其中，并将其作为参数传递给处理程序</p>
<ul>
<li>event.type<ul>
<li>事件类型</li>
</ul>
</li>
<li>event.currentTarget<ul>
<li>与this相同（除非是箭头函数，或this被绑定其他东西）</li>
</ul>
</li>
<li>event.eventPhase<ul>
<li>当前阶段（capturing=1，target=2，bubbling=3）</li>
</ul>
</li>
</ul>
<h2 id="冒泡和捕获"><a href="#冒泡和捕获" class="headerlink" title="冒泡和捕获"></a>冒泡和捕获</h2><h3 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h3><blockquote>
<p>当一个事件发生在一个元素上，它会首先运行在该元素上的处理程序，然后运行其父元素上的处理程序，然后一直向上到其他祖先上的处理程序</p>
</blockquote>
<p>几乎所有事件都是冒泡，例外：focus事件</p>
<p>event.target</p>
<ul>
<li>父元素上的处理程序始终可以获取事件<strong>实际发生位置</strong>的详细信息</li>
<li>与this和event.currentTarget不同，它们是“当前”元素</li>
</ul>
<h4 id="停止冒泡"><a href="#停止冒泡" class="headerlink" title="停止冒泡"></a>停止冒泡</h4><p>event.stopPropagation</p>
<ul>
<li>event.stopPropagation() 停止向上移动，但是当前元素上的其他处理程序都会继续运行。</li>
<li>event.stopImmediatePropagation() 方法，可以用于停止冒泡，并阻止当前元素上的处理程序运行。使用该方法之后，其他处理程序就不会被执行</li>
</ul>
<h3 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h3><p>事件传播三个阶段</p>
<ol>
<li>捕获阶段<ul>
<li>事件（从 Window）向下走近元素</li>
</ul>
</li>
<li>目标阶段<ul>
<li>事件到达目标元素</li>
</ul>
</li>
<li>冒泡阶段</li>
</ol>
<p>事件是默认是冒泡，修改为捕获阶段的操作： capture 选项设置为 true。</p>
<p>用addEventListener添加事件为捕获时，移除的时候也要标注为捕获，这样才能正确删除处理程序</p>
<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><blockquote>
<p>如果我们有许多以类似方式处理的元素，那么就不必为每个元素分配一个 处理程序 —— 而是将单个处理程序放在它们的共同祖先上。</p>
<p>事件必须是冒泡</p>
</blockquote>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ol>
<li>在容器（container）上放一个处理程序</li>
<li>在处理程序中 —— 检查源元素 event.target</li>
<li>如果事件发生在我们感兴趣的元素内，那么处理该事件。</li>
</ol>
<p>搭配下列方法，做事件委托</p>
<ul>
<li>event.target.closest(selector)<ul>
<li>返回与 selector 匹配的最近的祖先</li>
</ul>
</li>
<li>selector1.containes(selector2)<ul>
<li>检查selector2是否在selector1中</li>
</ul>
</li>
</ul>
<h3 id="“行为”模式"><a href="#“行为”模式" class="headerlink" title="“行为”模式"></a>“行为”模式</h3><blockquote>
<p>使用事件委托将“行为（behavior）”以 声明方式 添加到具有特殊特性 （attribute）和类的元素中</p>
</blockquote>
<p>行为模式分为两个部分</p>
<ol>
<li>我们将自定义特性<strong>添加</strong>到描述其行为的元素</li>
<li>用文档范围级的处理程序追踪事件，如果事件发生在具有特定特性的元素上 —— 则执行行为（action）。</li>
</ol>
<h2 id="浏览器默认行为"><a href="#浏览器默认行为" class="headerlink" title="浏览器默认行为"></a>浏览器默认行为</h2><h3 id="阻止浏览器行为方式"><a href="#阻止浏览器行为方式" class="headerlink" title="阻止浏览器行为方式"></a>阻止浏览器行为方式</h3><ul>
<li>event.preventDefault()</li>
<li>如果处理程序是使用<code>on&lt;event&gt;</code>，则返回false也有效</li>
<li>如果默认行为被阻止，则event.defaultPrevented属性为true，否则为false</li>
</ul>
<p>event.stopPropagation() 和 event.preventDefault()</p>
<p>之间毫无相关，一个是阻止冒泡，一个是阻止默认行为</p>
<h2 id="创建自定义事件"><a href="#创建自定义事件" class="headerlink" title="创建自定义事件"></a>创建自定义事件</h2><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><ol>
<li><p><code>new Event(type, [, options])</code></p>
<ul>
<li><p>type: 类型</p>
</li>
<li><p>options</p>
<ul>
<li>bubbles: true/false —— 如果为 true ，那么事件会冒泡</li>
<li>cancelable: true/false —— 如果为 true ，那么“默认行为”就会被阻止<ul>
<li>如果 event.preventDefault() 应该有效，则 cancelable: true</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>`new CustomEvent(type, detail)</p>
</li>
</ol>
<h3 id="派发-dispatchEvent-event"><a href="#派发-dispatchEvent-event" class="headerlink" title="派发 dispatchEvent(event)"></a>派发 dispatchEvent(event)</h3><blockquote>
<p>相当于触发了这个event事件</p>
</blockquote>
<h3 id="事件的发生顺序"><a href="#事件的发生顺序" class="headerlink" title="事件的发生顺序"></a>事件的发生顺序</h3><p>事件中的事件是<strong>同步的</strong>，通常事件是在队列中处理的。也就是说：如果浏览器正在处理 onclick ，这时发生了 一个新的事件，例如鼠标移动了，那么它的处理程序会被排入队列，相应的 mousemove 处理程序将在 onclick 事件处理完成后被调用</p>
<p>但也有例外：一个事件是在另一个事件<strong>中</strong>发起的。例如使用 dispatchEvent 。这类事件将会被立即处理，即在新的事件处理程序被调用之后， 恢复到当前的事件处理程序</p>
<ul>
<li>例如点击事件里面的处理程序中又派发了事件，则这类事件将会被立即处理</li>
</ul>
]]></content>
      <categories>
        <category>现代Javascript教程</category>
      </categories>
      <tags>
        <tag>浏览器事件</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是Javascript</title>
    <url>/2022/01/05/%E4%BB%80%E4%B9%88%E6%98%AFJavascript/</url>
    <content><![CDATA[<h2 id="Javascript历史回顾"><a href="#Javascript历史回顾" class="headerlink" title="Javascript历史回顾"></a>Javascript历史回顾</h2><blockquote>
<p> 最开始是为了解决验证简单的表单需要大量与服务器的往返进行通信，由客户端处理输入验证</p>
</blockquote>
<p>最早有两个版本的Javascript</p>
<ol>
<li>网景的Javascript</li>
<li>微软IE的JScript</li>
</ol>
<p>由于有两个版本的并存，急需要对Javascript进行规范其语法或特性标准，所以多家厂商联合，发布了<code>ECMA-262</code>，也就是<code>ECMAScript</code>这个脚本语法标准</p>
<span id="more"></span>

<h2 id="Javascript是什么"><a href="#Javascript是什么" class="headerlink" title="Javascript是什么"></a>Javascript是什么</h2><p>包含三个部分</p>
<h3 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h3><blockquote>
<p><code>ECMAScript</code>是<code>ECMA-262</code>定义的语言，并不局限在Web浏览器</p>
</blockquote>
<p>Web浏览器、NodeJs都只是<code>ECMAScript</code>实现的一种宿主环境。在基本层面上，<code>ECMA-262</code>定义了这门语言的语法、类型、语句、关键字、保留字、操作符、全局对象。</p>
<h4 id="ECMAScript的主要版本更新"><a href="#ECMAScript的主要版本更新" class="headerlink" title="ECMAScript的主要版本更新"></a><code>ECMAScript</code>的主要版本更新</h4><ul>
<li>第一版与网景的Javascript1.1基本相同，删除了所有浏览器特定的代码</li>
<li>第三版更新了字符串处理、错误定义、数值定义，增加正则表达式、新的控制语句、<code>try/catch</code>异常处理的支持</li>
<li>第四版修改颇多，几乎定义了一个新的语言废弃</li>
<li>第五版就是3.1版，增加原生的解析和序列化JSON数据的JSON对象、方便基乘和高级属性定义的方法</li>
<li>第六版，俗称ES6，正式支持类、模块、迭代器、生成器、箭头函数、期约、反射、代理和众多新的数据类型</li>
<li>第八版，增加异步函数(<code>async/await</code>)，<code>Object.values()/Object.entries()/Object.getOwnPropertyDescriptors()</code>和字符串填充方法，明确对象字面量最后的逗号</li>
<li>第九版，异步迭代、剩余、扩展属性，新的正则表达式特性、<code>Promisefinally()</code>，模板字面量修订</li>
<li>第十版，<code>Array.prototype.flat()/flatMap()、String.prototype.trimStart()/trimEnd()、Object.fromEntries()</code>方法，以及<code>Symbol.prototype.description</code>属性，定义<code>Function.prototype.toString()</code>返回值，并固定<code>Array.prototype.sort()</code>的顺序，解决JSON字符串兼容的问题。定义catch子句的可选绑定。</li>
</ul>
<h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><blockquote>
<p>使用<code>ECMAScript</code>的核心类型和语法，提供与环境的额外功能，是一个应用编程接口（API），用于在HTML中使用扩展的XML</p>
</blockquote>
<p>DOM通过创建表示文档的树，通过DOMAPI进行增删查改节点，可以做到不刷新页面而修改页面外观和内容。</p>
<p>DOM三个Level</p>
<ol>
<li>Level1目标是映射文档结构</li>
<li>Level2新增模块<ul>
<li>DOM视图</li>
<li>DOM事件</li>
<li>DOM样式</li>
<li>DOM遍历和范围</li>
</ul>
</li>
<li>Level3增加了以统一的方式加载和保存文档的方法（包含在一个叫DOMLoadandSave的新模块中），还有验证文档的方法（DOMValidation）。</li>
</ol>
<h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><blockquote>
<p>用于支持访问和操作浏览器窗口，操控浏览器显示页面之外的部分，主要针对浏览器窗口和子窗口</p>
</blockquote>
<ul>
<li>弹出新浏览器窗口的能力</li>
<li>移动、缩放和关闭浏览器窗口的能力</li>
<li>navigator对象，提供关于浏览器的详尽信息</li>
<li>location对象，提供浏览器加载页面的详尽信息</li>
<li>screen对象，提供关于用户屏幕分辨率的详尽信息</li>
<li>performance对象，提供浏览器内存占用、导航行为和时间统计的详尽信息</li>
<li>对cookie的支持</li>
<li>其他自定义对象，如XMLHttpRequest和IE的ActiveXObject</li>
</ul>
<h2 id="Javascript与ECMASCript的关系"><a href="#Javascript与ECMASCript的关系" class="headerlink" title="Javascript与ECMASCript的关系"></a>Javascript与ECMASCript的关系</h2><p><code>ECMAScript</code>只是对<code>ECMA-262</code>实现规范描述的所有方面的一门语言的称呼，而Javascript实现了<code>ECMAScript</code>，Javascript是包含<code>ECMAScript</code></p>
<p>原则上<code>JavaScript</code>与<code>ECMAScript</code>指的是同一个东西，但有时也会加以区分</p>
<ul>
<li><code>JavaScript</code>：指语言及其实现</li>
<li><code>ECMAScript</code>：指语言标准及语言版本</li>
</ul>
]]></content>
      <categories>
        <category>Javascript高级程序设计</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>作用域和闭包</title>
    <url>/2022/03/22/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><blockquote>
<p>设计良好的规则来存储变量，并且之后可以方便找到这些变量，这套规则被称为作用域</p>
</blockquote>
<span id="more"></span>

<h3 id="传统编译语言流程"><a href="#传统编译语言流程" class="headerlink" title="传统编译语言流程"></a>传统编译语言流程</h3><ol>
<li><p>分词/词法分析</p>
<p>将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元（token）</p>
</li>
<li><p>解析/语法分析</p>
<p>将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”</p>
</li>
<li><p>代码生成</p>
<p>将AST转换未可执行代码的过程</p>
</li>
</ol>
<h3 id="三个部分"><a href="#三个部分" class="headerlink" title="三个部分"></a>三个部分</h3><ul>
<li>引擎<ul>
<li>从头到尾负责整个JavaScript程序的编译及执行过程</li>
</ul>
</li>
<li>编译器<ul>
<li>负责语法分析及代码生成</li>
</ul>
</li>
<li>作用域<ul>
<li>负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限</li>
</ul>
</li>
</ul>
<p>例子：<code>vara=2</code></p>
<ul>
<li>一个由编译器在编译时处理<ul>
<li>遇到<code>vara</code>，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为a</li>
</ul>
</li>
<li>另一个则由引擎在运行时处理<ul>
<li>遇到<code>a=2</code>，引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作a的变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量</li>
</ul>
</li>
</ul>
<h3 id="两种查询"><a href="#两种查询" class="headerlink" title="两种查询"></a>两种查询</h3><ul>
<li>LHS查询<ul>
<li>如果查找的目的是对变量进行赋值，那么就会使用LHS查询</li>
<li>赋值操作的目标是谁</li>
</ul>
</li>
<li>RHS查询<ul>
<li>如果目的是获取变量的值，就会使用RHS查询</li>
<li>谁是赋值操作的源头</li>
</ul>
</li>
</ul>
<h3 id="作用域嵌套"><a href="#作用域嵌套" class="headerlink" title="作用域嵌套"></a>作用域嵌套</h3><blockquote>
<p>当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止</p>
</blockquote>
<p>遍历嵌套作用域链规则</p>
<p>引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止</p>
<h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><blockquote>
<p>简单地说，词法作用域就是定义在词法阶段的作用域。词法作用域是一套关于引擎如何寻找变量以及会在何处找到变量的规则。词法作用域最重要的特征是它的定义过程发生在代码的<strong>书写阶段</strong>，因此当词法分析器处理代码时会保持作用域不变</p>
</blockquote>
<p>作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”，但欺骗词法作用域会导致性能下降。</p>
<ul>
<li>有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符</li>
<li>编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。</li>
</ul>
<h3 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h3><ul>
<li>eval</li>
<li>with</li>
</ul>
<p>词法作用域和动态作用域主要区别</p>
<ul>
<li>词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的。词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用</li>
</ul>
<h2 id="函数作用域和块作用域"><a href="#函数作用域和块作用域" class="headerlink" title="函数作用域和块作用域"></a>函数作用域和块作用域</h2><blockquote>
<p>作用域包含了一系列的“气泡”，每一个都可以作为容器，其中包含了标识符（变量、函数）的定义。这些气泡互相嵌套并且整齐地排列成蜂窝型，排列的结构是在<strong>写代码时定义的</strong></p>
<p>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用</p>
<p>任何声明在某个作用域内的变量，都将附属于这个作用域</p>
</blockquote>
<h3 id="隐藏内部实现"><a href="#隐藏内部实现" class="headerlink" title="隐藏内部实现"></a>隐藏内部实现</h3><p>从所写的代码中挑选出一个任意的片段，然后用函数声明对它进行包装，实际的结果就是在这个代码片段的周围创建了一个作用域气泡，这段代码中的任何声明都将绑定在这个新创建的包装函数的作用域中，而不是先前所在的作用域中。换句话说，可以把变量和函数包裹在一个函数的作用域中，然后用这个作用域来“隐藏”它们。</p>
<p>好处</p>
<ul>
<li>最小授权或最小暴露原则</li>
<li>避免同名标识符之间的冲突</li>
</ul>
<p>缺点</p>
<ul>
<li>函数名污染了所在作用域</li>
<li>不能够自动运行</li>
</ul>
<p>改良</p>
<ul>
<li>使用立即执行函数表达式<code>IIFE</code><ul>
<li>进阶用法：把它们当作函数调用并传递参数进去</li>
<li>还有一种用途：倒置代码的运行顺序，将需要运行的函数放在第二位，在 IIFE 执行之后当作参数传递进去</li>
</ul>
</li>
<li></li>
</ul>
<h3 id="匿名和具名"><a href="#匿名和具名" class="headerlink" title="匿名和具名"></a>匿名和具名</h3><ul>
<li>函数表达式可以是匿名的， 而函数声明则不可以省略函数名</li>
<li>匿名函数在栈追踪中不会显示出有意义的函数名</li>
<li>匿名函数省略了对于代码可读性 / 可理解性很重要的函数名</li>
</ul>
<h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><ul>
<li>with</li>
<li>try/catch</li>
<li>let<ul>
<li>可以将变量绑定到所在的任意作用域中</li>
</ul>
</li>
</ul>
<h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2><p>包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理</p>
<ul>
<li>var变量声明，函数声明都会有提升</li>
<li>重复声明时，函数声明会<strong>覆盖</strong>普通变量声明，并且重复的var声明会<strong>被忽略掉</strong>，但出现在后面的函数声明还是可以覆盖前面的</li>
</ul>
<h2 id="作用域闭包"><a href="#作用域闭包" class="headerlink" title="作用域闭包"></a>作用域闭包</h2><blockquote>
<p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。</p>
</blockquote>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    	<span class="built_in">console</span>.log( a );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> baz = foo();</span><br><span class="line">baz(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。这个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的词法作用域。</p>
<p>无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包</p>
<p>只要使用回调函数，实际上就是在使用闭包</p>
<h3 id="循环和闭包"><a href="#循环和闭包" class="headerlink" title="循环和闭包"></a>循环和闭包</h3><p>经典例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( i );</span><br><span class="line">    &#125;, i*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果是五次6</p>
<p>我们试图假设循环中的每个迭代在运行时都会给自己“捕获”一个<code>i</code>的副本。但是根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的， 但是它们都被封闭在一个共享的全局作用域中，因此<strong>实际上只有一个<code> i</code></strong></p>
<p>解决方法：</p>
<ol>
<li><p>```javascript<br>for (var i=1; i&lt;=5; i++) {</p>
<pre><code>(function(j) &#123;
setTimeout( function timer() &#123;
    console.log( j );
    &#125;, j*1000 );
&#125;)( i );
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   在迭代内使用 IIFE 会**为每个迭代都生成一个新的作用域**，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。</span><br><span class="line"></span><br><span class="line">2. ```javas</span><br><span class="line">   for (let i=1; i&lt;=5; i++) &#123;</span><br><span class="line">       setTimeout( function timer() &#123;</span><br><span class="line">       console.log( i );</span><br><span class="line">       &#125;, i*1000 );</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>for 循环头部的 let 声明还会有一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，<strong>每次迭代都会声明</strong>。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量</p>
</li>
</ol>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>两个必要条件</p>
<ul>
<li>必须有外部的封闭函数，该函数必须至少被调用一次</li>
<li>封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态</li>
</ul>
<p>一个具有函数属性的对象本身并不是真正的模块。从方便观察的角度看，一个从函数调用所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。</p>
<p>通过在模块实例的内部保留对公共 API 对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法和属性，以及修改它们的值。</p>
<p>模块文件中的内容会被当作好像包含在作用域闭包中一样来处理，就和前面介绍的函数闭包模块一样</p>
]]></content>
      <categories>
        <category>你不知道的Javascript</category>
      </categories>
      <tags>
        <tag>作用域</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>代理与反射</title>
    <url>/2022/01/10/%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h2 id="代理基础"><a href="#代理基础" class="headerlink" title="代理基础"></a>代理基础</h2><blockquote>
<p>当目标对象上的进行一些特定的底层操作时，代理允许你<strong>拦截这些操作并且覆写</strong>它</p>
</blockquote>
<ul>
<li>使用<code>Proxy</code>构造函数创建的，两个参数<ul>
<li>第一个参数：目标对象</li>
<li>第二个参数：处理程序对象</li>
</ul>
</li>
<li>给目标属性赋值会反映在两个对象上</li>
<li>给代理属性赋值会反映在两个对象上</li>
<li><strong><code>Proxy.prototype</code>是<code>undefined</code></strong></li>
<li>严格相等可以用来区分代理和目标</li>
</ul>
<span id="more"></span>

<p>主要目的是可以定义捕获器（<code>trap</code>）。捕获器就是在处理程序对象中定义的“基本操作的拦截器”。每个捕获器都对应一种基本操作，可以直接或间接在代理对象上调用。每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为。</p>
<h3 id="捕获器不变式"><a href="#捕获器不变式" class="headerlink" title="捕获器不变式"></a>捕获器不变式</h3><blockquote>
<p>捕获器不变式因方法不同而异，但通常都会防止捕获器定义出现过于反常的行为</p>
</blockquote>
<p>例如：如果目标对象有一个不可配置且不可写的数据属性，那么在捕获器返回一个与该属性不同的值时，会抛出<code>TypeError</code></p>
<h3 id="可撤销代理"><a href="#可撤销代理" class="headerlink" title="可撤销代理"></a>可撤销代理</h3><ul>
<li><code>Proxy</code>也暴露了<code>revocable()</code>方法，这个方法支持撤销代理对象与目标对象的关联</li>
<li>撤销代理的操作是不可逆的</li>
<li>是幂等的</li>
<li>撤销代理之后再调用代理会抛出<code>TypeError</code></li>
</ul>
<h3 id="实用反射API"><a href="#实用反射API" class="headerlink" title="实用反射API"></a>实用反射API</h3><blockquote>
<p>反射方法适用于细粒度的对象控制与操作</p>
</blockquote>
<ol>
<li><p>状态标记</p>
<blockquote>
<p>返回称作“状态标记”的布尔值，表示意图执行的操作是否成功。以下反射方法都会提供状态标记</p>
</blockquote>
<ul>
<li><code>Reflect.defineProperty()</code></li>
<li><code>Reflect.preventExtensions()</code></li>
<li><code>Reflect.setPrototypeOf()</code></li>
<li><code>Reflect.set()</code></li>
<li><code>Reflect.deleteProperty()</code></li>
</ul>
</li>
<li><p>用一等函数替代操作符</p>
<blockquote>
<p>以下反射方法提供只有通过操作符才能完成的操作</p>
</blockquote>
<ul>
<li>`Reflect.get()<ul>
<li>替代对象属性访问操作符</li>
</ul>
</li>
<li><code>Reflect.set()</code><ul>
<li>替代=赋值操作符</li>
</ul>
</li>
<li><code>Reflect.has()</code><ul>
<li>替代in操作符或<code>with()</code></li>
</ul>
</li>
<li><code>Reflect.deleteProperty()</code><ul>
<li>替代<code>delete</code>操作符</li>
</ul>
</li>
<li><code>Reflect.construct()</code><ul>
<li>替代<code>new</code>操作符</li>
</ul>
</li>
</ul>
</li>
<li><p>安全地应用函数</p>
<ul>
<li><code>Reflect.apply()</code></li>
</ul>
</li>
</ol>
<h3 id="代理另一个代理"><a href="#代理另一个代理" class="headerlink" title="代理另一个代理"></a>代理另一个代理</h3><blockquote>
<p>可以创建一个代理，通过它去代理另一个代理</p>
</blockquote>
<p>代理问题</p>
<ol>
<li><code>this</code>问题</li>
<li>内部槽位</li>
</ol>
<h2 id="代码捕获器与反射方法"><a href="#代码捕获器与反射方法" class="headerlink" title="代码捕获器与反射方法"></a>代码捕获器与反射方法</h2><blockquote>
<p>对于在代理对象上执行的任何一种操作，只会有一个捕获处理程序被调用。不会存在重复捕获的情况。</p>
<p>只要在代理上调用，所有捕获器都会拦截它们对应的反射API操作</p>
</blockquote>
<table>
<thead>
<tr>
<th>捕获器</th>
<th>操作</th>
<th>反射</th>
<th>返回值</th>
<th>参数</th>
</tr>
</thead>
<tbody><tr>
<td>get()`</td>
<td>获取属性值操作</td>
<td><code>Reflect.get()</code></td>
<td>无限制</td>
<td>target、property、receiver</td>
</tr>
<tr>
<td><code>set()</code></td>
<td>设置属性值</td>
<td><code>Reflect.set()</code></td>
<td>布尔值</td>
<td>target、property、value、receiver</td>
</tr>
<tr>
<td><code>has()</code></td>
<td><code>in</code>操作符</td>
<td><code>Reflect.has()</code></td>
<td>布尔值</td>
<td>target、property</td>
</tr>
<tr>
<td><code>defineProperty()</code></td>
<td>被调用</td>
<td><code>Reflect.defineProperty()</code></td>
<td>布尔值</td>
<td>target、property、descriptor</td>
</tr>
<tr>
<td><code>getOwnPropertyDescriptor()</code></td>
<td>被调用</td>
<td><code>Reflect.getOwnPropertyDescriptor()</code></td>
<td>返回对象，属性不存在返回<code>undefined</code></td>
<td>target、property</td>
</tr>
<tr>
<td><code>deleteProperty()</code></td>
<td><code>delete</code>操作符</td>
<td><code>Reflect.deleteProperty()</code></td>
<td>布尔值</td>
<td>target、property</td>
</tr>
<tr>
<td><code>ownKeys()</code></td>
<td><code>Object.keys()</code>及类似方法中被调用</td>
<td><code>Reflect.ownKeys()</code></td>
<td>返回字符串或符号的可枚举对象</td>
<td>target：目标对象</td>
</tr>
<tr>
<td><code>getPrototypeOf()</code></td>
<td>被调用</td>
<td><code>Reflect.getPrototypeOf()</code></td>
<td>返回对象或<code>null</code></td>
<td>target：目标对象</td>
</tr>
<tr>
<td><code>setPrototypeOf()</code></td>
<td><code>Object.setPrototypeOf()</code>中被调用</td>
<td><code>Reflect.setPrototypeOf()</code></td>
<td>布尔值</td>
<td>target、prototype</td>
</tr>
<tr>
<td><code>isExtensible()</code></td>
<td><code>Object.isExtensible()</code>中被调用</td>
<td><code>Reflect.isExtensible()</code></td>
<td>布尔值</td>
<td>target：目标对象</td>
</tr>
<tr>
<td><code>preventExtensions()</code></td>
<td>被调用</td>
<td><code>Reflect.preventExtensions()</code></td>
<td>布尔值</td>
<td>target：目标对象</td>
</tr>
<tr>
<td><code>apply()</code></td>
<td>调用函数时中被调用</td>
<td><code>Reflect.apply()</code></td>
<td>无限制</td>
<td>target、thisArgargumentsList</td>
</tr>
<tr>
<td><code>construct()</code></td>
<td>在<code>new</code>操作符中被调用</td>
<td><code>Reflect.construct()</code></td>
<td>对象</td>
<td>target、argumentsList、newTarget</td>
</tr>
</tbody></table>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="跟踪属性访问"><a href="#跟踪属性访问" class="headerlink" title="跟踪属性访问"></a>跟踪属性访问</h3><p>通过捕获<code>get</code>、<code>set</code>和<code>has</code>等操作，可以知道对象属性什么时候被访问、被查询。把实现相应捕获器的某个对象代理放到应用中，可以监控这个对象何时在何处被访问过</p>
<h3 id="隐藏属性"><a href="#隐藏属性" class="headerlink" title="隐藏属性"></a>隐藏属性</h3><p>代理的内部实现对外部代码是不可见的，因此要隐藏目标对象上的属性也轻而易举</p>
<h3 id="属性验证"><a href="#属性验证" class="headerlink" title="属性验证"></a>属性验证</h3><p>因为所有赋值操作都会触发set()捕获器，所以可以根据所赋的值决定是允许还是拒绝赋值</p>
<h3 id="函数与构造函数参数验证"><a href="#函数与构造函数参数验证" class="headerlink" title="函数与构造函数参数验证"></a>函数与构造函数参数验证</h3><p>跟保护和验证对象属性类似，也可对函数和构造函数参数进行审查。比如，可以让函数只接收某种类型的值</p>
<h3 id="数据绑定与可观察对象"><a href="#数据绑定与可观察对象" class="headerlink" title="数据绑定与可观察对象"></a>数据绑定与可观察对象</h3><p>通过代理可以把运行时中原本不相关的部分联系到一起。这样就可以实现各种模式，从而让不同的代码互操作</p>
]]></content>
      <categories>
        <category>Javascript高级程序设计</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>变量、作用域与内存</title>
    <url>/2022/01/06/%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h2 id="通过变量使用原始值与引用值"><a href="#通过变量使用原始值与引用值" class="headerlink" title="通过变量使用原始值与引用值"></a>通过变量使用原始值与引用值</h2><ol>
<li>原始值<ul>
<li>最简单的数据，大小固定，保存在栈内存中，保存原始值的变量按值访问</li>
<li>不能有属性，但尝试添加属性不报错</li>
<li>使用new关键字，Javascript会创建一个Object类型的实例，但其行为类似原始值</li>
<li>赋值到另一个变量时，是新增一个新的原始值</li>
</ul>
</li>
<li>引用值<ul>
<li>由多个值构成的对象，存储在堆内存中，保存引用值的变量按引用访问</li>
<li>可以随时增删改其属性和方法</li>
<li>赋值到另一个变量时，只是复制了指针地址，没有新增一个对象</li>
</ul>
</li>
</ol>
<span id="more"></span>

<p>相同点：</p>
<ul>
<li>传递参数都是<strong>按值传递</strong><ul>
<li>原始值，传原始值</li>
<li>引用值，传指针地址</li>
</ul>
</li>
</ul>
<p>确认类型</p>
<ul>
<li>typeof适合用来判断一个变量是否为原始类型（字符串、数值、布尔值或undefined）</li>
<li>instanceof来判断它是什么类型对象<ul>
<li>用instanceof检测原始值，则始终会返回false</li>
</ul>
</li>
</ul>
<p>在把一个值赋给变量时，JavaScript引擎必须确定这个值是原始值还是引用值。</p>
<h2 id="理解执行上下文"><a href="#理解执行上下文" class="headerlink" title="理解执行上下文"></a>理解执行上下文</h2><blockquote>
<p>执行上下文就是当前代码的执行环境，包括全局执行上下文（就是最外层的上下文），函数执行上下文</p>
</blockquote>
<ul>
<li>全局执行上下文：创建一个全局的window对象（浏览器的情况下），并且设置<code>this</code>的值等于这个全局对象。</li>
<li>函数执行上下文：每当一个函数被调用时,都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。</li>
</ul>
<p>js引擎内部有一个执行上下文栈，它是用于执行代码的调用栈，最底部是全局执行上下文栈，当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。</p>
<h3 id="理解三个重要属性"><a href="#理解三个重要属性" class="headerlink" title="理解三个重要属性"></a>理解三个重要属性</h3><ol>
<li><p>变量对象</p>
<p>每个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量和函数都存在于这个对象上。我们编写的代码无法访问变量对象</p>
<p><strong>活动对象</strong></p>
<blockquote>
<p>在函数上下文中，我们用活动对象来表示变量对象，活动对象和变量对象其实是一个东西，只有当进入一个执行环境时，这个执行上下文的变量对象才会被激活，此时称为活动对象（AO），只有活动对象上的各种属性才能被访问。</p>
<p>活动对象是在进入函数上下文时刻被创建的，最初只有一个定义变量：arguments（全局上下文中没有这个变量），它通过函数的arguments属性初始化。arguments属性值是Arguments对象（调用函数时，会为其创建一个Arguments对象，并自动初始化局部变量arguments，指代该Arguments对象。所有作为参数传入的值都会成为Arguments对象的数组元素。）</p>
</blockquote>
<p>变量对象和活动对象的关系：</p>
<p>未进入执行阶段之前，变量对象(VO)中的属性都不能访问，但是进入执行阶段之后，变量对象(VO)转变为了活动对象(AO)，里面的属性都能被访问了，然后开始进行执行阶段的操作。</p>
<p><strong>它们其实都是同一个对象，只是处于执行上下文的不同生命周期</strong></p>
</li>
<li><p>作用域链</p>
<p>上下文中的代码在执行的时候，会创建变量对象的一个作用域链。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。内部上下文可以通过作用域链访问外部上下文中的一切，但外部上下文无法访问内部上下文中的任何东西。</p>
</li>
<li><p>this</p>
</li>
</ol>
<h3 id="执行上下文的生命周期"><a href="#执行上下文的生命周期" class="headerlink" title="执行上下文的生命周期"></a>执行上下文的生命周期</h3><p>可以分为两个个阶段</p>
<ol>
<li><p>创建阶段</p>
<blockquote>
<p>在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向。</p>
</blockquote>
<ol>
<li>创建变量对象<ul>
<li>初始化函数的所有形参<ul>
<li>由名称和对应值组成的一个变量对象的属性被创建</li>
<li>没有实参，属性值设为undefined</li>
</ul>
</li>
<li>初始化函数声明<ul>
<li>由名称和对应值（function-object）组成一个变量对象的属性被创建</li>
<li>如果变量对象已经存在相同名称的属性，则完全替换这个属性</li>
</ul>
</li>
<li>初始变量声明<ul>
<li>由名称和对应值（undefined）组成一个变量对象的属性被创建</li>
<li>如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性</li>
</ul>
</li>
</ul>
</li>
<li>建立作用域</li>
<li>确定this指向</li>
</ol>
</li>
<li><p>代码执行阶段</p>
<blockquote>
<p>创建完成之后，就会开始执行代码，这个时候，会完成变量赋值，函数引用，以及执行其他代码。</p>
</blockquote>
</li>
</ol>
<h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><ul>
<li>var声明，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文，如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文</li>
</ul>
<h3 id="标识符查找"><a href="#标识符查找" class="headerlink" title="标识符查找"></a>标识符查找</h3><p>搜索开始于作用域链前端，以给定的名称搜索对应的标识符。如果在局部上下文中找到该标识符，则搜索停止，变量确定；如果没有找到变量名，则继续沿作用域链搜索。这个过程一直持续到搜索至全局上下文的变量对象。如果仍然没有找到标识符，则说明其未声明。</p>
<h2 id="理解垃圾回收"><a href="#理解垃圾回收" class="headerlink" title="理解垃圾回收"></a>理解垃圾回收</h2><p>Javascript通过自动内存管理实现内存分配和闲置资源回收。思路：确定哪个变量不会再使用，然后释放它占用的内存。这个过程是周期性的，即垃圾回收程序每隔一定时间（或者说在代码执行过程中某个预定的收集时间）就会自动运行</p>
<p>两种策略</p>
<h3 id="标记清理"><a href="#标记清理" class="headerlink" title="标记清理"></a>标记清理</h3><p>当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记；当变量离开上下文时，也会被加上离开上下文的标记。</p>
<p>给变量加标记得两种实现思路</p>
<ul>
<li>当变量进入上下文时，反转某一位</li>
<li>维护“在上下文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表</li>
</ul>
<p>标记过程的实现并不重要，关键是策略</p>
<p>垃圾回收运行过程</p>
<ul>
<li>会标记内存中存储的所有变量</li>
<li>将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉</li>
<li>在此之后再被加上标记的变量就是待删除的了吗，因为任何在上下文中的变量都访问不到它们了</li>
<li>垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存</li>
</ul>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>思路</p>
<ul>
<li>对每个值都记录它被引用的次数</li>
<li>声明变量并给它赋一个引用值时，这个值的引用数为1</li>
<li>如果同一个值又被赋给另一个变量，那么引用数加1</li>
<li>如果保存对该值引用的变量被其他值给覆盖了，那么引用数减1</li>
<li>当一个值的引用数为0时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了</li>
<li>释放引用数为0的值的内存</li>
</ul>
<p>缺陷</p>
<p>会有可能出现循环引用，如：对象A有一个指针指向对象B，而对象B也引用了对象A</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可能造成性能损失，因此垃圾回收的时间调度很重要。</p>
<p>现代垃圾回收程序会基于对JavaScript运行时环境的探测来决定何时运行。探测机制因引擎而异，但基本上都是根据已分配对象的大小和数量来判断的。V8的堆增长策略会根据<strong>活跃对象的数量外加一些余量</strong>来确定何时再次垃圾回收。</p>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>分配给浏览器得内存通常很小，因为要出于安全考虑，为的是避免运行大量JavaScript的网页耗尽系统内存而导致操作系统崩溃。内存限制不仅影响变量分配，也影响调用栈以及能够同时在一个线程中执行的语句数量。</p>
<p>优化内存方法</p>
<blockquote>
<p>优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据。如果数据不再必要，那么把它设置为null，从而释放其引用。这也可以叫作解除引用。这个建议最适合全局变量和全局对象的属性</p>
</blockquote>
<ol>
<li><p>使用<code>const</code>和<code>let</code>声明</p>
<p>块级作用域能更早地让垃圾回收程序介入，今早回收应该回收地内存</p>
</li>
<li><p>隐藏类和删除操作</p>
<ul>
<li>V8会将创建的对象与隐藏类关联起来，以跟踪它们的属性特征。如果这实例共享同一个构造函数和原型，V8会在后台配置，共享相同的隐藏类<ul>
<li>后面如果某个实例新增新的属性，他们不会共享相同隐藏类，所以要避免JavaScript的“先创建再补充”式的动态属性赋值，并在构造函数中一次性声明所有属性</li>
</ul>
</li>
<li>动态删除属性与动态添加属性导致的后果一样。最佳实践是把不想要的属性设置为null。这样可以保持隐藏类不变和继续共享，同时也能达到删除引用值供垃圾回收程序回收的效果</li>
</ul>
</li>
<li><p>静态分配（这个方法，大多数情况下，这都属于过早优化）</p>
<p>关键点：减少浏览器执行垃圾回收的次数。理论上，如果能够合理使用分配的内存，同时避免多余的垃圾回收，那就可以保住因释放内存而损失的性能</p>
<p>浏览器决定何时运行垃圾回收程序的一个标准就是对象更替的速度。</p>
<p>思路：</p>
<ol>
<li><p>使用对象池。在初始化的某一时刻，可以创建一个对象池，用来管理一组可回收的对象。</p>
</li>
<li><p>应用程序可以向这个对象池请求一个对象、设置其属性、使用它，然后在操作完成后再把它还给对象池。</p>
</li>
<li><p>由于没发生对象初始化，垃圾回收探测就不会发现有对象更替，因此垃圾回收程序就不会那么频繁地运行。</p>
</li>
</ol>
</li>
</ol>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>JavaScript中的内存泄漏大部分是由不合理的引用导致的</p>
<p>可能出现的场景</p>
<ol>
<li><p>定时器导致</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Jake&quot;</span>;</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>只要定时器一直运行，回调函数中引用的name就会一直占用内存。因而垃圾回收程序就不会清理外部变量。</p>
</li>
<li><p>闭包</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> outer = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&quot;Jake&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>闭包一直引用这外部函数的变量，垃圾回收程序无法去清理</p>
</li>
</ol>
<h2 id="Javascript代码执行过程"><a href="#Javascript代码执行过程" class="headerlink" title="Javascript代码执行过程"></a>Javascript代码执行过程</h2><ol>
<li>编译阶段<ol>
<li>词法分析</li>
<li>语法分析</li>
<li>可执行代码生成</li>
<li>作用域确定</li>
</ol>
</li>
<li>执行阶段<ol>
<li>进入执行上下文声明周期<ol>
<li>创建阶段<ol>
<li>生成变量对象<ol>
<li>创建argument对象</li>
<li>检查function函数声明</li>
<li>检查var变量声明</li>
</ol>
</li>
<li>建立作用域链</li>
<li>确定this指向</li>
</ol>
</li>
<li>执行阶段<ol>
<li>变量赋值</li>
<li>函数引用</li>
<li>执行其他代码</li>
</ol>
</li>
</ol>
</li>
<li>代码执行</li>
<li>垃圾回收<ul>
<li>上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数，全局上下文在应用程序退出前才会被销毁。</li>
</ul>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Javascript高级程序设计</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>函数</title>
    <url>/2022/01/11/%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="函数表达式、函数声明及箭头函数"><a href="#函数表达式、函数声明及箭头函数" class="headerlink" title="函数表达式、函数声明及箭头函数"></a>函数表达式、函数声明及箭头函数</h2><ol>
<li>函数表达式<ul>
<li>必须等到代码执行到它那一行，才会在执行上下文中生成函数定义</li>
</ul>
</li>
<li>函数声明<ul>
<li>JavaScript 引擎在任何代码执行之前，会先读取函数声明，并在执行上下文中生成函数定义<ul>
<li>这个过程叫函数声明提升</li>
</ul>
</li>
</ul>
</li>
<li>箭头函数<ul>
<li>非常适合嵌入函数</li>
<li>不能使用 arguments、super 和 new.target，也不能用作构造函数</li>
<li>没有 prototype 属性</li>
</ul>
</li>
</ol>
<p>函数名就是指向函数地指针。</p>
<span id="more"></span>

<h3 id="理解参数"><a href="#理解参数" class="headerlink" title="理解参数"></a>理解参数</h3><p>参数在内部表现为一个数组，在使用 function 关键字定义（非箭头）函数时，可以在函数内部访问 arguments 对象，从中取得传进来的每个参数值。</p>
<p>每个函数在被调用时都会自动创建两个特殊变量：this 和 arguments。内部函数永远不可能直接访问外部函数的这两个变量。</p>
<h3 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h3><ul>
<li>一个类数组对象（但不是 Array 的实例）</li>
<li>可以通过 arguments 对象的 length 属性检查传入的参数个数</li>
<li>可以跟命名参数一起使用</li>
<li>它的值始终会与对应的命名参数同步<ul>
<li>修改arguments上的值，会使得命名参数的值会变化</li>
<li>它们在内存中是分开的，只不过会保持同步</li>
</ul>
</li>
<li>有一个callee属性，是一个指向 arguments 对象所在函数的指针<ul>
<li>使用 arguments.callee 就可以让函数逻辑与函数名解耦</li>
</ul>
</li>
</ul>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><blockquote>
<p>在标准函数中，this 引用的是把函数当成方法调用的上下文对象，这时候通常称其为 this 值</p>
</blockquote>
<ul>
<li>在标准函数中，<strong>this 到底引用哪个对象必须到函数被调用时才能确定</strong></li>
<li>在箭头函数中，<strong>this引用的是定义箭头函数的上下文</strong></li>
</ul>
<p>函数没有重载，后定义的会覆盖先定义</p>
<h3 id="函数属性"><a href="#函数属性" class="headerlink" title="函数属性"></a>函数属性</h3><ol>
<li>new.target<ul>
<li>如果函数是正常调用的，则 new.target 的值是 undefined；如果是使用 new 关键字调用的，则 new.target 将引用被调用的构造函数。</li>
</ul>
</li>
<li>length<ul>
<li>保存函数定义的命名参数的个数</li>
</ul>
</li>
<li>prototype<ul>
<li>保存引用类型所有实例方法的地方</li>
</ul>
</li>
</ol>
<h3 id="apply-、call-、bind-区别"><a href="#apply-、call-、bind-区别" class="headerlink" title="apply()、call()、bind()区别"></a>apply()、call()、bind()区别</h3><p>第一个参数都是this的值</p>
<ul>
<li>apply()<ul>
<li>第二个参数可以是Array实例，也可以是arguments对象</li>
</ul>
</li>
<li>call()<ul>
<li>除去第一个参数，剩下参数都是逐个传递传给到被调用函数</li>
</ul>
</li>
<li>bind()<ul>
<li>bind()方法会创建一个新的函数实例， 其 this 值会被绑定到传给 bind()的对象</li>
</ul>
</li>
</ul>
<p>使用 apply()还是 call()，完全取决于怎么给要调用的函数传参更方便，他们真正强大的地方并不是给函数传参，而是<strong>控制函数调用上下文即函数体内 this 值的能力</strong></p>
<h2 id="默认参数及扩展操作符"><a href="#默认参数及扩展操作符" class="headerlink" title="默认参数及扩展操作符"></a>默认参数及扩展操作符</h2><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>ES6之后，支持显式定义默认参数。给参数传 undefined 相当于没有传值。</p>
<p>默认参数上，实际上和使用 let 关键字顺序声明变量一样，按照定义它们的顺序依次被初始化，后定义默认值的参数可以引用先定义的参数，但反过来不行，会有TDZ，参数也存在于自己的作用域中，它们不能引用函数体的作用域。</p>
<h3 id="扩展操作符"><a href="#扩展操作符" class="headerlink" title="扩展操作符"></a>扩展操作符</h3><p>扩展操作符既可以用于调用函数时传参，也可以用于定义函数参数</p>
<h2 id="使用函数实现递归"><a href="#使用函数实现递归" class="headerlink" title="使用函数实现递归"></a>使用函数实现递归</h2><blockquote>
<p>递归函数通常的形式是一个函数通过名称调用自己</p>
</blockquote>
<p>在写递归函数时使用 arguments.callee 可以避免函数名被改名，导致递归出错这个问题</p>
<h3 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h3><blockquote>
<p>内存管理优化机制，让 JavaScript 引擎在满足条件时可以重用栈帧。具体来说，即外部函数的返回值是一个内部函数的返回值。</p>
</blockquote>
<p>优化条件</p>
<blockquote>
<p>尾调用优化的条件就是确定外部栈帧真的没有必要存在了</p>
</blockquote>
<ul>
<li>代码在严格模式下执行<ul>
<li>之所以要求严格模式，主要因为在非严格模式下函数调用中允许使用 f.arguments 和 f.caller，而它们都会引用外部函数的栈帧。</li>
</ul>
</li>
<li><strong>外部函数的返回值是对尾调用函数的调用</strong></li>
<li>尾调用函数<strong>返回后不需要执行额外的逻辑</strong></li>
<li>尾调用函数<strong>不是引用外部函数作用域中自由变量的闭包</strong></li>
</ul>
<h2 id="使用闭包实现私有变量"><a href="#使用闭包实现私有变量" class="headerlink" title="使用闭包实现私有变量"></a>使用闭包实现私有变量</h2><blockquote>
<p>闭包：指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。</p>
</blockquote>
<p>回顾作用域链概念</p>
<blockquote>
<p>在调用一个函数时，会为这个函数调用创建一个执行上下文，并创建一个作用域链。然后用 arguments 和其他命名参数来初始化这个函数的活动对象。外部函数的活动对象是内部函数作用域链上的第二个对象。这个作用域链一直向外串起了所有包含函数的活动对象，直到全局执行上下文才终止</p>
</blockquote>
<p>函数执行时，每个执行上下文中都会有一个包含其中变量的对象。全局上下文中的叫变量对象，它会在代码执行期间始终存在。而函数局部上下文中的叫活动对象，只在函数执行期间存在。在定义函数时，就会为它创建作用域链，预装载全局变量对象，并保存在内部的[[Scope]]中。在调用这个函数时，会创建相应的执行上下文，然后通过复制函数的[[Scope]]来创建其作用域链。接着会创建函数的活动对象（用作变量对象）并将其推入作用域链的前端。</p>
<p>作用域链其实是一个包含指针的列表，每个指针分别指向一个变量对象，但物理上并不会包含相应的对象。</p>
<p>在一个函数内部定义的函数会把外部函数的的活动对象添加到自己的作用域链中，外部函数活动对象并不能在它执行完毕后销毁，因为内部函数的作用域链中仍然有对它的引用，外部函数执行上下文的作用域链会销毁，但它的活动对象仍然会保留在内存中，直到内部函数被销毁后才会被销毁</p>
<p>因为闭包会保留它们包含函数的作用域，所以比其他函数更占用内存。过度使用闭包可能导致内存过度占用，因此建议仅在十分必要时使用。</p>
<p>闭包有时会产生<strong>内存泄漏</strong></p>
<h3 id="立即调用的函数表达式IIFE"><a href="#立即调用的函数表达式IIFE" class="headerlink" title="立即调用的函数表达式IIFE"></a>立即调用的函数表达式IIFE</h3><blockquote>
<p>类似于函数声明，但由于被包含在括号中，所以会被解释为函数表达式。紧跟在第一组括号后面的第二组括号会立即调用前面的函数表达式</p>
</blockquote>
<p>ES5以前，为了防止变量定义外泄，IIFE 是个非常有效的方式，ES6之后，IIFE 就没有那么必要了，因为块级作用域中的变量无须 IIFE 就可以实现同样的隔离</p>
<h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><blockquote>
<p>任何定义在函数或块中的变量，都可以认为是私有的，因为在这个函数或块的外部无法访问其中的变量，私有变量包括函数参数、局部变量，以及函数内部定义的其他函数</p>
</blockquote>
<p>如果这个函数中创建了一个闭包，则这个闭包能通过其作用域链访问其外部的这 3 个变量。基于这一点，就可以创建出能够访问私有变量的公有方法</p>
<p>特权方法是能够访问函数私有变量（及私有函数）的公有方法</p>
<ul>
<li>这个模式是把所有私有变量和私有函数都定义在构造函数中。然后，再创建一个能够访问这些私有成员的特权方法。这样做之所以可行，是因为定义在构造函数中的特权方法其实是一个闭包，它具有访问构造函数中定义的所有变量和函数的能力。</li>
</ul>
<p>所带来的问题：必须通过构造函数来实现这种隔离</p>
<p>解决方法：使用静态私有变量实现特权方法可以避免这个问题。</p>
<h4 id="静态私有变量"><a href="#静态私有变量" class="headerlink" title="静态私有变量"></a>静态私有变量</h4><h4 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h4>]]></content>
      <categories>
        <category>Javascript高级程序设计</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>基本引用类型</title>
    <url>/2022/01/08/%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h2><p>引用类型是把数据和功能组织到一起的结构，有点像类，但和类不是一个概念</p>
<p>对象被认为是某个特定引用类型的实例。新对象通过使用new操作符后跟一个构造函数来创建。构造函数就是用来创建新对象的函数</p>
<p>JavaScript中的对象是引用值，可以通过几种内置引用类型创建特定类型的对象</p>
<span id="more"></span>

<ul>
<li>Object类型<ul>
<li>一个基础类型</li>
</ul>
</li>
<li>Array类型</li>
<li>Date类型</li>
<li>RegExp类型</li>
</ul>
<p>函数其实是Function类型的实例，这意味着函数也是对象。由于函数是对象，因此也就具有能够增强自身行为的方法</p>
<p>当代码开始执行时，全局上下文中会存在两个内置对象：<code>Global</code>和<code>Math</code>。其中，<code>Global</code>对象在大多数ECMAScript实现中无法直接访问。不过，浏览器将其实现为window对象。所有全局变量和函数都是<code>Global</code>对象的属性。<code>Math</code>对象包含辅助完成复杂计算的属性和方法</p>
<h2 id="基本Javascript数据类型"><a href="#基本Javascript数据类型" class="headerlink" title="基本Javascript数据类型"></a>基本Javascript数据类型</h2><h3 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h3><blockquote>
<p>Date类型将日期保存为自协调世界时（UTC，UniversalTimeCoordinated）时间1970年1月1日午夜（零时）至今所经过的毫秒数</p>
</blockquote>
<p>创建日期对象</p>
<ul>
<li><code>new Date()</code><ul>
<li>构造函数</li>
</ul>
</li>
<li>辅助方法：<ul>
<li><code>Date.parse()</code><ul>
<li>“月/日/年”</li>
<li>“月名日,年”</li>
<li>“周几月名日年时:分:秒时区”，</li>
<li><code>“YYYY-MM-DDTHH:mm:ss.sssZ”</code></li>
<li><code>Date.parse()</code>会被Date构造函数隐式调用</li>
</ul>
</li>
<li><code>Date.UTC()</code><ul>
<li><code>Date.UTC()</code>方法也返回日期的毫秒表示</li>
<li>参数是年、零起点月数（1月是0，2月是1，以此类推）、日（1<code>~</code>31）、时（0<code>~</code>23）、分、秒和毫秒</li>
<li><code>Date.UTC()</code>也会被Date构造函数隐式调用</li>
</ul>
</li>
</ul>
</li>
<li><code>Date.now()</code><ul>
<li>返回表示方法执行时日期和时间的毫秒数</li>
<li>方便用于代码分析，计算运行时长</li>
</ul>
</li>
<li><code>toLocaleString()</code><ul>
<li>返回与浏览器运行的本地环境一致的日期和时间</li>
</ul>
</li>
<li><code>toString()</code><ul>
<li>返回带时区信息的日期和时间，而时间也是以24小时制（0~23）表示的</li>
</ul>
</li>
<li><code>valueOf()</code><ul>
<li>返回的是日期的毫秒表示</li>
</ul>
</li>
</ul>
<p>日期格式化方法</p>
<h3 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h3><p><code>RegExp</code>类型支持正则表达式</p>
<ul>
<li><code>g</code><ul>
<li>全局模式</li>
</ul>
</li>
<li><code>i</code><ul>
<li>不区分大小写</li>
</ul>
</li>
</ul>
<p>所有元字符在模式中也必须转义</p>
<ul>
<li><code>([&#123;\^$|)]&#125;?*+.</code></li>
<li>使用反斜杠来转义</li>
</ul>
<h4 id="正则表达式创建"><a href="#正则表达式创建" class="headerlink" title="正则表达式创建"></a>正则表达式创建</h4><ul>
<li>字面量定义</li>
<li><code>RegExp</code>构造函数创建<ul>
<li>两个参数<ul>
<li>模式字符串<ul>
<li>因为是字符串，所以所有元字符都必须二次转义，<strong>包括转义字符序列</strong></li>
</ul>
</li>
<li>（可选）标记字符串</li>
</ul>
</li>
<li>可以基于已有的正则表达式实例，并可选择性地修改它们的标记</li>
</ul>
</li>
</ul>
<h4 id="RegExp实例方法"><a href="#RegExp实例方法" class="headerlink" title="RegExp实例方法"></a>RegExp实例方法</h4><ol>
<li><p><code>exec()</code></p>
<p>主要用于配合捕获组使用。这个方法只接收一个参数，即要应用模式的字符串。如果找到了匹配项，则<strong>返回包含第一个匹配信息的数组</strong>；如果没找到匹配项，则返回null。</p>
<p>这个数组的第一个元素是匹配整个模式的字符串，其他元素是与表达式中的捕获组匹配的字符串</p>
<p>两个额外属性</p>
<ul>
<li><code>index</code><ul>
<li>字符串中匹配模式的起始位置</li>
</ul>
</li>
<li><code>input</code><ul>
<li>是要查找的字符串</li>
</ul>
</li>
</ul>
<p>如果模式设置了全局标记，则每次调用<code>exec()</code>方法会返回一个匹配的信息；如果没有设置全局标记，则无论对同一个字符串调用多少次exec()，也只会返回第一个匹配的信息</p>
</li>
<li><p><code>test()</code></p>
<p>接收一个字符串参数。如果输入的文本与模式匹配，则参数返回<code>true</code>，否则返回<code>false</code>。主要用于测试模式是否匹配。</p>
<p><code>toLocaleString()</code>和<code>toString()</code>都返回正则表达式的字面量表示，<code>valueOf()</code>方法返回正则表达式本身</p>
</li>
</ol>
<h2 id="原始值与原始值包装类型"><a href="#原始值与原始值包装类型" class="headerlink" title="原始值与原始值包装类型"></a>原始值与原始值包装类型</h2><blockquote>
<p>每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法。</p>
</blockquote>
<ul>
<li>每种包装类型都映射到同名的原始类型</li>
<li>在以读模式访问原始值时，后台会实例化一个原始值包装对象，通过这个对象可以操作数据</li>
<li>涉及原始值的语句只要一执行完毕，包装对象就会立即销毁</li>
</ul>
<p>当原始值调用对象方法或属性时，发生三个事情</p>
<ul>
<li>创建原始值包装类型</li>
<li>调用实例上特定的方法</li>
<li>销毁实例</li>
</ul>
<p>引用类型与原始值包装类型的<strong>主要区别在于对象的生命周期</strong>。在通过new实例化引用类型后，得到的实例会在离开作用域时被销毁，而自动创建的原始值包装对象则<strong>只存在于访问它的那行代码执行期间</strong>。</p>
<p>三个原始值包装类型</p>
<h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><blockquote>
<p><code>Boolean</code>是对应布尔值的引用类型。要创建一个<code>Boolean</code>对象，就使用<code>Boolean</code>构造函数并传入<code>true</code>或<code>false</code></p>
</blockquote>
<ul>
<li>重写<code>valueOf()</code>方法，返回一个原始值true或false</li>
<li><code>toString()</code>方法被调用时也会被覆盖，返回字符串”true”或”false”</li>
</ul>
<h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><h4 id="重写了valueOf-、toLocaleString-和toString-方法"><a href="#重写了valueOf-、toLocaleString-和toString-方法" class="headerlink" title="重写了valueOf()、toLocaleString()和toString()方法"></a>重写了<code>valueOf()</code>、<code>toLocaleString()</code>和<code>toString()</code>方法</h4><ul>
<li><code>valueOf()</code>方法返回<code>Number</code>对象表示的原始数值</li>
<li>另外两个方法返回数值字符串</li>
<li><code>toString()</code>方法可选地接收一个表示基数的参数，并返回相应基数形式的数值字符串</li>
</ul>
<h4 id="将数值格式化为字符串方法"><a href="#将数值格式化为字符串方法" class="headerlink" title="将数值格式化为字符串方法"></a>将数值格式化为字符串方法</h4><ul>
<li><code>toFixed()</code><ul>
<li>返回包含指定小数点位数的数值字符串</li>
</ul>
</li>
<li><code>toExponential()</code><ul>
<li>返回以科学记数法（也称为指数记数法）表示的数值字符串</li>
<li>接收一个参数，表示结果中小数的位数</li>
</ul>
</li>
<li><code>toPrecision()</code><ul>
<li>接收一个参数，表示结果中数字的总位数</li>
</ul>
</li>
</ul>
<p><code>Number.isInteger()</code>方法，用于辨别一个数值是否保存为整数</p>
<p>为了鉴别整数是否在合理数字范围内，可以使用<code>Number.isSafeInteger()</code>方法</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><blockquote>
<p>String是对应字符串的引用类型。要创建一个String对象，使用String构造函数并传入一个数值</p>
</blockquote>
<p><code>valueOf()</code>、<code>toLocaleString()</code>和<code>toString()</code>都返回对象的原始字符串值，有一个<code>length</code>属性，表示字符串中字符的数量。</p>
<p>JavaScript字符串由16位码元（codeunit）组成，在Unicode中称为基本多语言平面（BMP）</p>
<ul>
<li><code>charAt()</code>方法<ul>
<li>返回给定索引位置的字符，由传给方法的整数参数指定</li>
</ul>
</li>
<li><code>charCodeAt()</code><ul>
<li>可以查看指定码元的字符编码</li>
<li>返回指定索引位置的码元值</li>
</ul>
</li>
<li><code>fromCharCode()</code><ul>
<li>用于根据给定的UTF-16码元创建字符串中的字符</li>
<li>可以接受任意多个数值，并返回将所有数值对应的字符拼接起来的字符串</li>
</ul>
</li>
</ul>
<p>对于扩展到Unicode增补字符平面时，Unicode采用了一个策略，即每个字符使用另外16位去选择一个增补平面。这种每个字符使用两个16位码元的策略称为<strong>代理对</strong></p>
<ul>
<li><code>codePointAt()</code><ul>
<li>接收16位码元的索引并返回该索引位置上的码点(能识别完整的码点（16位或32位）)<ul>
<li>码点是Unicode中一个字符的完整标识</li>
</ul>
</li>
</ul>
</li>
<li><code>fromCodePoint()</code><ul>
<li>接收任意数量的码点，返回对应字符拼接起来的字符串</li>
</ul>
</li>
<li><code>normalize()</code><ul>
<li>规范化字符串</li>
</ul>
</li>
</ul>
<p>字符串操作方法</p>
<ul>
<li><code>concat()</code><ul>
<li>将一个或多个字符串拼接成一个新字符串</li>
<li><code>concat()</code>方法可以接收任意多个参数，因此可以一次性拼接多个字符串</li>
<li>更常用的时<code>+</code>运算符</li>
</ul>
</li>
<li>提取子字符串<ul>
<li><code>slice()</code><ul>
<li>第一个参数表示开始，第二个表示结束</li>
<li>将所有负值参数都当成字符串长度加上负参数值</li>
</ul>
</li>
<li><code>substr()</code><ul>
<li>第一个参数表示开始，第二个表示返回子字符串数量</li>
<li>将第一个负参数值当成字符串长度加上该值，将第二个负参数值转换为0</li>
</ul>
</li>
<li><code>substring()</code><ul>
<li>第一个参数表示开始，第二个表示结束</li>
<li>将所有负参数值都转换为0</li>
</ul>
</li>
</ul>
</li>
<li>定位子字符串<ul>
<li><code>indexOf()</code><ul>
<li>从开头开始查找子字符串</li>
</ul>
</li>
<li><code>lastIndexOf()</code><ul>
<li>从末尾开始查找子字符串</li>
</ul>
</li>
<li>都可以接收可选的第二个参数，表示开始搜索的位置</li>
</ul>
</li>
<li>判断字符串是否包含另一个字符串<ul>
<li><code>startswith</code><ul>
<li>检查开始于索引0的匹配项</li>
<li>可选第二参数，表示开始搜索位置</li>
</ul>
</li>
<li><code>endsWith</code><ul>
<li>检查开始于索引(<code>string.length-substring.length</code>)的匹配项</li>
<li>可选第二参数，表示当作字符串末尾位置</li>
</ul>
</li>
<li><code>includes</code><ul>
<li>检查整个字符串</li>
<li>可选第二参数，表示开始搜索位置</li>
</ul>
</li>
</ul>
</li>
<li><code>trim()</code><ul>
<li>创建字符串副本，删除前后所有空格符</li>
<li><code>trimLeft()</code></li>
<li><code>trimRight()</code></li>
</ul>
</li>
<li><code>repeat</code><ul>
<li>接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果。</li>
</ul>
</li>
<li>填充字符<ul>
<li><code>padStart()</code></li>
<li><code>padEnd()</code></li>
<li>第一个参数是长度，第二个参数是可选的填充字符串</li>
<li>如果长度小于或等于字符串长度，则会返回原始字符串</li>
</ul>
</li>
<li>字符串迭代于结构<ul>
<li>原型上暴露了一个@@iterator方法，表示可以迭代字符串的每个字符，在for-of循环中可以通过这个迭代器按序访问每个字符，有了这个迭代器之后，字符串就可以通过解构操作符来解构了</li>
</ul>
</li>
<li>字符串大小写转换<ul>
<li><code>toLowerCase()</code></li>
<li><code>toUpperCase()</code></li>
<li><code>toLocaleLowerCase()</code><ul>
<li>基于特定地区实现</li>
</ul>
</li>
<li><code>toLocaleUpperCase()</code><ul>
<li>基于特定地区实现</li>
</ul>
</li>
</ul>
</li>
<li>字符串模式匹配<ul>
<li><code>match()</code></li>
<li><code>search()</code></li>
<li><code>replace()</code><ul>
<li>第二个参数可以是函数</li>
</ul>
</li>
<li><code>split()</code><ul>
<li>可传第二参数，确保返回数组大小不超过第二参数</li>
</ul>
</li>
</ul>
</li>
<li>localeCompare()<ul>
<li>比较两个字符串，排前头返回负值，排后头返回正值，相等返回0</li>
</ul>
</li>
</ul>
<h3 id="单例内置对象"><a href="#单例内置对象" class="headerlink" title="单例内置对象"></a>单例内置对象</h3><blockquote>
<p>任何由ECMAScript实现提供、与宿主环境无关，并在ECMAScript程序开始执行时就存在的对象</p>
</blockquote>
<h4 id="Global"><a href="#Global" class="headerlink" title="Global"></a>Global</h4><blockquote>
<p>Global对象为一种兜底对象，它所针对的是不属于任何对象的属性和方法</p>
</blockquote>
<p>方法</p>
<ul>
<li>URI编码方法<ul>
<li><code>encodeURI()</code><ul>
<li>不会编码属于URL组件的特殊字符，比如冒号、斜杠、问号、井号</li>
</ul>
</li>
<li><code>encodeURIComponent()</code><ul>
<li>会编码它发现的所有非标准字符</li>
</ul>
</li>
</ul>
</li>
<li>URI解码方式<ul>
<li><code>decodeURI()</code></li>
<li><code>decodeURIComponent()</code></li>
</ul>
</li>
</ul>
<p><code>window</code>对象</p>
<blockquote>
<p>浏览器将window对象实现为Global对象的代理</p>
</blockquote>
<p>当一个函数在没有明确指定this值的情况下执行时，this值等于Global对象</p>
<h4 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h4><blockquote>
<p>保存数学公式、信息和计算的地方</p>
</blockquote>
<ul>
<li><code>min()</code>与<code>max()</code></li>
<li>舍入方法<ul>
<li><code>ceil()</code><ul>
<li>向上取整</li>
</ul>
</li>
<li><code>floor()</code><ul>
<li>向下取整</li>
</ul>
</li>
<li><code>round()</code><ul>
<li>四舍五入</li>
</ul>
</li>
<li><code>fround()</code><ul>
<li>返回数值最接近的单精度（32位）浮点值</li>
</ul>
</li>
</ul>
</li>
<li>random()<ul>
<li>返回0-1范围内的随机数，包含0，不包含1</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Javascript高级程序设计</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建一个自己的博客</title>
    <url>/2022/01/04/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="Hexo-快速搭建"><a href="#Hexo-快速搭建" class="headerlink" title="Hexo 快速搭建"></a>Hexo 快速搭建</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul>
<li>git</li>
<li>node</li>
<li>npm</li>
</ul>
<span id="more"></span>

<p>命令行里验证有无安装成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git --version</span><br><span class="line">git version 2.24.0.windows.1</span><br><span class="line"></span><br><span class="line">$ node --version</span><br><span class="line">v14.17.5</span><br><span class="line"></span><br><span class="line">$ npm --version</span><br><span class="line">6.14.14</span><br></pre></td></tr></table></figure>

<h4 id="配置SSH-Key"><a href="#配置SSH-Key" class="headerlink" title="配置SSH Key"></a>配置SSH Key</h4><p>如果第一次用git工具，记得配置一下SSH key，为部署本地博客到 Github 做准备。</p>
<p>如果之前没有创建，则执行以下命令全局配置一下本地账户：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;邮箱地址&quot;</span></span><br></pre></td></tr></table></figure>

<p>生成密钥SSK key</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&#x27;上面的邮箱&#x27;</span></span><br></pre></td></tr></table></figure>

<p>回车回车回车，即可生成ssh key。<code>.ssh</code>目录下有两个文件，<code>id_rsa</code>和<code>id_rsa.pub</code>，这两个就是ssh key的密钥对，前一个是私钥，后一个是公钥</p>
<p>cat获取你的ssh</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>复制输出内容</p>
<p>登录github，settings -&gt; SSH and GPG keys -&gt; New SSH key</p>
<p>Title随便写</p>
<p>Key把刚才复制的内容copy到这，就确认完成了。</p>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli	<span class="comment"># -g 代表着全局安装</span></span><br></pre></td></tr></table></figure>

<p>完成后建立自己的个人博客</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo init blogName</span><br><span class="line">$ <span class="built_in">cd</span> blogName</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>

<h3 id="创建你的第一篇博文"><a href="#创建你的第一篇博文" class="headerlink" title="创建你的第一篇博文"></a>创建你的第一篇博文</h3><p>新建一篇博文：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">$ hexo <span class="keyword">new</span> <span class="string">&#x27;新年快乐&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在 <code>/source/_posts</code>文件夹下找到你的博文，使用typora（推荐）打开并编辑。</p>
<p>保存后运行：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo generate <span class="comment"># 生成静态文件，可简写为 hexo g</span></span><br><span class="line"><span class="variable">$ </span>hexo server <span class="comment"># 启动服务器。默认情况下，访问网址为：http://localhost:4000/。可以简写为 hexo s</span></span><br></pre></td></tr></table></figure>

<p>此时已经可以在<code>public</code>文件夹下看到完整的静态文件。<br>在浏览器中输入<code>http://localhost:4000/</code>就可以看到预览效果了。</p>
<p>以上是本地部署，下面讲博客部署到Github page上</p>
<h2 id="部署到Github-page"><a href="#部署到Github-page" class="headerlink" title="部署到Github page"></a>部署到Github page</h2><p>登录github，新建仓库，仓库名为<code>username.github.io</code>，<strong>注意：<code>username</code>应该是你github的用户名</strong></p>
<p>本地和github都完成之后，现在需要把这两者连接在一起</p>
<ol>
<li><p>修改配置</p>
<p>在项目根目录下的<code>_config.yml</code>修改配置参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo:</span><br><span class="line">    github: https://github.com/你的用户名/你的用户名.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li>
<li><p>安装部署插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p><code>hexo-deploy-git </code>插件是通过拷贝 <code>public</code> 文件夹内容到<code>.deploy_git</code>文件夹下，然后提交推送到远程分支上实现了网站文件的部署。</p>
</li>
<li><p>启动执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure></li>
</ol>
<p> 用浏览器输入，https://你的用户名.github.io，就可以看到你的博客了。</p>
<h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p>个人用的是<a href="https://theme-next.js.org/">NexT主题</a></p>
<p>进入项目根目录，下载NexT主题</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/next-theme/hexo-theme-next themes/next</span></span><br></pre></td></tr></table></figure>

<p>修改<strong>项目根目录</strong>下的<code>_config.yml</code>的配置</p>
<p>注意：<code>_config.yml</code>配置文件有两个，一个在项目根目录，一个在<code>/themes/next</code>中，大部分配置在主题里面改。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<h2 id="NexT配置"><a href="#NexT配置" class="headerlink" title="NexT配置"></a>NexT配置</h2><p>以下均在<code>_config.yml</code>文件中修改</p>
<h3 id="修改NexT风格"><a href="#修改NexT风格" class="headerlink" title="修改NexT风格"></a>修改NexT风格</h3><p>NexT主题有四个风格，想要的取消注释</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line">scheme: Mist</span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br></pre></td></tr></table></figure>

<h3 id="暗黑模式"><a href="#暗黑模式" class="headerlink" title="暗黑模式"></a>暗黑模式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Dark Mode</span></span><br><span class="line">darkmode: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="改变网页标签icon"><a href="#改变网页标签icon" class="headerlink" title="改变网页标签icon"></a>改变网页标签icon</h3><p>把你想要用的图片放在<code>/themes/next/source/images</code>中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: /images/favicon-16x16-next.ico</span><br><span class="line">  medium: /images/favicon-32x32-next.ico</span><br></pre></td></tr></table></figure>

<p>插一个提示，可以在<a href="https://www.bitbug.net/">比特虫</a>在线制作icon</p>
<h3 id="增加或删除博客页面功能"><a href="#增加或删除博客页面功能" class="headerlink" title="增加或删除博客页面功能"></a>增加或删除博客页面功能</h3><p>想用的取消注释，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || fa fa-home</span><br><span class="line">  about: /about/ || fa fa-user</span><br><span class="line">  tags: /tags/ || fa fa-tags</span><br><span class="line">  categories: /categories/ || fa fa-th</span><br><span class="line">  archives: /archives/ || fa fa-archive</span><br><span class="line">  <span class="comment">#schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || fa fa-heartbeat</span></span><br></pre></td></tr></table></figure>

<h4 id="添加标签页面"><a href="#添加标签页面" class="headerlink" title="添加标签页面"></a>添加标签页面</h4><p>在项目根目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br><span class="line"><span class="built_in">cd</span> ./<span class="built_in">source</span>/tags</span><br></pre></td></tr></table></figure>

<p>打开<code>index.md</code>文件，增加一个<code>type</code>字段</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false</span><br><span class="line">date: 2022-01-04 13:29:07</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h4 id="添加分类页面"><a href="#添加分类页面" class="headerlink" title="添加分类页面"></a>添加分类页面</h4><p>在项目根目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br><span class="line"><span class="built_in">cd</span> ./<span class="built_in">source</span>/categories</span><br></pre></td></tr></table></figure>

<p>打开<code>index.md</code>文件，增加一个<code>type</code>字段</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">date: 2022-01-04 13:55:58</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h4 id="添加about页面"><a href="#添加about页面" class="headerlink" title="添加about页面"></a>添加about页面</h4><p>在项目根目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br><span class="line"><span class="built_in">cd</span> ./<span class="built_in">source</span>/about</span><br></pre></td></tr></table></figure>

<p>打开<code>index.md</code>文件，里面直接写你的个人介绍。</p>
<h3 id="调整侧边栏位置"><a href="#调整侧边栏位置" class="headerlink" title="调整侧边栏位置"></a>调整侧边栏位置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sidebar:</span><br><span class="line">  <span class="comment"># Sidebar Position.</span></span><br><span class="line">  <span class="comment">#position: left</span></span><br><span class="line">  position: right</span><br></pre></td></tr></table></figure>

<h3 id="添加侧边栏头像图片"><a href="#添加侧边栏头像图片" class="headerlink" title="添加侧边栏头像图片"></a>添加侧边栏头像图片</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line">avatar:</span><br><span class="line">  <span class="comment"># 把要展示的图片放在images中</span></span><br><span class="line">  url: /images/avatar.jpg</span><br><span class="line">  <span class="comment"># If true, the avatar will be displayed in circle.</span></span><br><span class="line">  rounded: <span class="literal">false</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be rotated with the cursor.</span></span><br><span class="line">  rotated: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="启用不蒜子统计"><a href="#启用不蒜子统计" class="headerlink" title="启用不蒜子统计"></a>启用不蒜子统计</h3><p>不蒜子是用于统计文章添加阅读次数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  total_visitors: <span class="literal">true</span></span><br><span class="line">  total_visitors_icon: fa fa-user</span><br><span class="line">  total_views: <span class="literal">true</span></span><br><span class="line">  total_views_icon: fa fa-eye</span><br><span class="line">  post_views: <span class="literal">true</span></span><br><span class="line">  post_views_icon: fa fa-eye</span><br></pre></td></tr></table></figure>

<h3 id="添加加载进度条"><a href="#添加加载进度条" class="headerlink" title="添加加载进度条"></a>添加加载进度条</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd themes/next</span><br><span class="line">git clone https://github.com/theme-next/theme-next-pace source/lib/pace</span><br></pre></td></tr></table></figure>

<p>修改配置文件 <code>themes/next/_config.yml</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pace:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  theme: minimal</span><br></pre></td></tr></table></figure>

<h3 id="添加页面顶部阅读进度条"><a href="#添加页面顶部阅读进度条" class="headerlink" title="添加页面顶部阅读进度条"></a>添加页面顶部阅读进度条</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd themes/next</span><br><span class="line">git clone https://github.com/theme-next/theme-next-reading-progress source/lib/reading_progress</span><br></pre></td></tr></table></figure>

<p>修改配置文件 <code>themes/next/_config.yml</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">reading_progress:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  position: top               <span class="comment"># 进度条的位置：top | bottom</span></span><br><span class="line">  color: <span class="string">&quot;#37c6c0&quot;</span>            <span class="comment"># 进度条的颜色</span></span><br><span class="line">  height: 3px                 <span class="comment"># 进度条的大小</span></span><br></pre></td></tr></table></figure>

<h3 id="显示侧栏阅读进度百分比"><a href="#显示侧栏阅读进度百分比" class="headerlink" title="显示侧栏阅读进度百分比"></a>显示侧栏阅读进度百分比</h3><p>修改配置文件 <code>themes/next/_config.yml</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">back2top:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  sidebar: <span class="literal">false</span></span><br><span class="line">  scrollpercent: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="字数与阅读时长统计插件"><a href="#字数与阅读时长统计插件" class="headerlink" title="字数与阅读时长统计插件"></a>字数与阅读时长统计插件</h3><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> 项目根目录</span><br><span class="line">npm install eslint --save</span><br><span class="line">npm install hexo-symbols-count-<span class="built_in">time</span> --save</span><br></pre></td></tr></table></figure>

<p>修改配置文件 <code>themes/next/_config.yml</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  time: <span class="literal">true</span>                   <span class="comment"># 文章阅读时长</span></span><br><span class="line">  symbols: <span class="literal">true</span>                <span class="comment"># 文章字数统计</span></span><br><span class="line">  total_time: <span class="literal">true</span>             <span class="comment"># 站点总阅读时长</span></span><br><span class="line">  total_symbols: <span class="literal">true</span>          <span class="comment"># 站点总字数统计</span></span><br><span class="line">  exclude_codeblock: <span class="literal">true</span>      <span class="comment"># 排除代码字数统计</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="添加搜索功能"><a href="#添加搜索功能" class="headerlink" title="添加搜索功能"></a>添加搜索功能</h3><p>进入项目根目录，下载插件<code>hexo-generator-searchdb</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install  hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>修改主题配置文件，添加<code>search</code>，并修改<code>local_search</code>中的<code>enable</code>，改为<code>true</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  <span class="built_in">limit</span>: 10000</span><br><span class="line">  </span><br><span class="line"><span class="comment"># Local search</span></span><br><span class="line">local_search:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="首页博文只展示部分文字"><a href="#首页博文只展示部分文字" class="headerlink" title="首页博文只展示部分文字"></a>首页博文只展示部分文字</h3><p>在文章想要分割的位置中添加一行<code>&lt;!--more--&gt;</code></p>
<h3 id="markdown上使用图片，网页上能正常显示"><a href="#markdown上使用图片，网页上能正常显示" class="headerlink" title="markdown上使用图片，网页上能正常显示"></a>markdown上使用图片，网页上能正常显示</h3><ul>
<li>修改根目录下的<code>_config.yml</code>文件，把<code>post_asset_folder</code>字段改为<code>true</code><ul>
<li>改为之后，新建文章时<code>hexo new 文章标题</code>，_posts不仅会出现md文件，而且会出现一个同名的<strong>文件夹</strong>，之后这个文件夹放你要引用的图片</li>
</ul>
</li>
<li>修改typora设置<img src="/2022/01/04/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/5dcd1adfc992651e437559aa46f4476.png" alt="5dcd1adfc992651e437559aa46f4476"><ul>
<li>以后拖拽图片进文章内之后，图片会自动添加到同名文件夹下面</li>
</ul>
</li>
<li>下载插件<code>npm install hexo-asset-image --save</code></li>
</ul>
<p>根据网上的信息，这时候就<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code>，按道理就能看到图片了，但结果我的就是不行，图片路径出现了<code>/.io//*******.png</code>，就前面会多出<code>/.io//</code>这个前缀，导致图片不能显示。</p>
<p><strong>解决方法</strong></p>
<p>修改一下项目根目录<code>/node_modules/hexo-asset-image/index.js</code>的24行左右，把 <code>link.lastIndexOf(&#39;.&#39;)</code> 修改为 <code>link.lastIndexOf(&#39;/&#39;)</code>就可以了。</p>
<p><img src="/2022/01/04/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/750ad85a47d9fa795e13bb8d4bf195e.png" alt="750ad85a47d9fa795e13bb8d4bf195e"></p>
<h2 id="备份数据"><a href="#备份数据" class="headerlink" title="备份数据"></a>备份数据</h2><ul>
<li><p>修改<code>.gitignore</code>文件，添加<code>package-lock.json</code> 到忽略清单中</p>
</li>
<li><p>创建 <code>themes_custom/next</code> 文件夹，将对主题进行的配件修改的文件拷贝一份到这里</p>
<ul>
<li>例如<code>_config.yml</code>文件和source文件中的imag</li>
</ul>
</li>
<li><p>执行以下命令，在本地创建备份仓库</p>
</li>
<li><p>```bash<br> cd blog<br>$ git init<br>已初始化空的 Git 仓库于 blog/.git/</p>
<p>$ git submodule add <a href="https://github.com/theme-next/hexo-theme-next.git">https://github.com/theme-next/hexo-theme-next.git</a> themes/next<br>添加位于 ‘themes/next’ 的现存仓库到索引</p>
<p>$ git add .<br>$ git commit -m “init blog backup”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 将备份内容 push 到远程仓库的备份分支 `hexo` 上：</span><br><span class="line"></span><br><span class="line">- ```bash</span><br><span class="line">   git branch -m master hexo</span><br><span class="line">  $ git remote add origin https://github.com/Mupceet/mupceet.github.io.git</span><br><span class="line">  $ git push -u origin hexo:hexo</span><br></pre></td></tr></table></figure></li>
</ul>
<p><a href="https://mupceet.com/2019/09/backup-hexo-blog">参考链接</a></p>
<h2 id="Hexo命令"><a href="#Hexo命令" class="headerlink" title="Hexo命令"></a>Hexo命令</h2><ul>
<li><code>hexo init [folder]</code> <ul>
<li>Hexo 默认在目前的文件夹建立网站。</li>
<li>Git clone <a href="https://github.com/hexojs/hexo-starter">hexo-starter</a> 和 <a href="https://github.com/hexojs/hexo-theme-landscape">hexo-theme-landscape</a> 主题到当前目录或指定目录。</li>
<li>使用 <a href="https://classic.yarnpkg.com/lang/en/">Yarn 1</a>、<a href="https://pnpm.js.org/">pnpm</a> 或 <a href="https://docs.npmjs.com/cli/install">npm</a> 包管理器下载依赖（如有已安装多个，则列在前面的优先）。npm 默认随 <a href="https://hexo.io/docs/#Install-Node-js">Node.js</a> 安装。</li>
</ul>
</li>
<li><code>hexo new &#39;文章标题&#39;</code><ul>
<li>新建文件，写的时候自己用typora打开写</li>
</ul>
</li>
<li><code>hexo clean</code><ul>
<li>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</li>
<li>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</li>
</ul>
</li>
<li><code>hexo generate</code><ul>
<li>生成静态文件，可简写为<code>hexo g</code></li>
</ul>
</li>
<li><code>hexo server</code><ul>
<li>启动服务器。默认情况下，访问网址为：<code>http://localhost:4000/</code>。可以简写为 hexo s</li>
</ul>
</li>
<li><code>hexo deploy</code><ul>
<li>部署网站，可简写为<code>hexo d</code></li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>新年快乐</title>
    <url>/2022/01/04/%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90/</url>
    <content><![CDATA[<p>2022年希望有更好的明天</p>
]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>理解执行上下文</title>
    <url>/2022/03/18/%E7%90%86%E8%A7%A3%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<h2 id="什么是执行上下文"><a href="#什么是执行上下文" class="headerlink" title="什么是执行上下文"></a>什么是执行上下文</h2><p>执行上下文就是当前代码的执行环境，包含三种类型</p>
<ul>
<li>全局执行上下文：创建一个全局的window对象（浏览器的情况下），并且设置<code>this</code>的值等于这个全局对象。</li>
<li>函数执行上下文：每当一个函数被调用时,都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。</li>
<li><code>Eval </code>函数执行上下文</li>
</ul>
<span id="more"></span>

<h2 id="执行上下文生命周期"><a href="#执行上下文生命周期" class="headerlink" title="执行上下文生命周期"></a>执行上下文生命周期</h2><p>可以分为三个阶段</p>
<h3 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h3><blockquote>
<p>在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向。</p>
</blockquote>
<ol>
<li><p>创建变量对象</p>
<blockquote>
<p><strong>细节：当遇到函数和变量同名且都会被提升的情况，函数声明优先级比较高，因此变量声明会被函数声明所覆盖，但是可以重新赋值。</strong></p>
<p>function声明的优先级比var声明高，也就意味着当两个同名变量同时被function和var声明时，function声明会覆盖var声明</p>
</blockquote>
<ol>
<li><p>初始化函数的所有形参</p>
<ul>
<li>由名称和对应值组成的一个变量对象的属性被创建</li>
<li>没有实参，属性值设为undefined</li>
</ul>
</li>
<li><p>初始化函数声明</p>
<ul>
<li>由名称和对应值（function-object）组成一个变量对象的属性被创建</li>
<li>如果变量对象已经存在相同名称的属性，则完全替换这个属性</li>
</ul>
</li>
<li><p>初始变量声明</p>
<ul>
<li><p>由名称和对应值（undefined）组成一个变量对象的属性被创建</p>
</li>
<li><p>如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>建立作用域</p>
<ol>
<li>上下文中的代码在执行的时候，会创建变量对象的一个作用域链。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。内部上下文可以通过作用域链访问外部上下文中的一切，但外部上下文无法访问内部上下文中的任何东西。</li>
</ol>
</li>
<li><p>确定this指向</p>
<ul>
<li> this的值是在执行的时候才能确认，定义的时候不能确认(箭头函数例外，箭头函数并不绑定this对象，this引用会从上层作用域中找到对应的this)</li>
</ul>
</li>
</ol>
<h3 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h3><p>一步步执行，完成对所有变量的分配，最后执行代码</p>
<h3 id="回收阶段"><a href="#回收阶段" class="headerlink" title="回收阶段"></a>回收阶段</h3><h2 id="什么是执行上下文栈"><a href="#什么是执行上下文栈" class="headerlink" title="什么是执行上下文栈"></a>什么是执行上下文栈</h2><blockquote>
<p>用于存储在代码执行期间创建的所有执行上下文，当 JavaScript 引擎首次读取你的脚本时，它会创建一个全局执行上下文并将其推入当前的执行栈。</p>
</blockquote>
<ul>
<li>每当发生一个函数调用，引擎都会为该函数创建一个新的执行上下文并将其推到当前执行栈的顶端，引擎会运行执行上下文在执行栈顶端的函数</li>
<li>当此函数运行完成后，其对应的执行上下文将会从执行栈中弹出，上下文控制权将移到当前执行栈的下一个执行上下文。</li>
</ul>
]]></content>
      <categories>
        <category>深入理解Javascript</category>
      </categories>
      <tags>
        <tag>执行上下文</tag>
      </tags>
  </entry>
  <entry>
    <title>2022日常</title>
    <url>/2022/01/07/%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="2022-01"><a href="#2022-01" class="headerlink" title="2022-01"></a>2022-01</h2>]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>语言基础</title>
    <url>/2022/01/06/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul>
<li><p>区分大小写</p>
</li>
<li><p>标识符</p>
<ul>
<li>首字符为字母、下划线、美元符号</li>
<li>建议使用驼峰大小写</li>
<li>关键字、保留字、true、false、null不能为标识符</li>
</ul>
</li>
<li><p>注释</p>
<ul>
<li>单行注释<code>//</code></li>
<li>块注释<code>/**/</code></li>
</ul>
</li>
<li><p>严格模式</p>
<ul>
<li>加一行<code>&quot;use strict&quot;</code></li>
<li>是一个预处理指令</li>
</ul>
</li>
<li><p>语句</p>
<ul>
<li><p>可以不分号结束，由解析器决定结尾，但建议都手动自己加分号</p>
</li>
<li><p>大括号里是代码块</p>
<span id="more"></span></li>
</ul>
</li>
<li><p>变量</p>
<ul>
<li><p><code>var</code></p>
<ul>
<li>函数级作用域</li>
<li>作用域提升</li>
<li>重复声明不报错</li>
<li>全局声明的变量成为window对象属性</li>
</ul>
</li>
<li><p><code>let</code></p>
<ul>
<li><p>块级作用域</p>
</li>
<li><p>没有提升，有暂时死区TDZ</p>
<ul>
<li><p>当程序流程进入新的作用域（module、function、block）进行实例化时，在此作用域中，用let、const声明的变量会先在作用域中被创建，但此时还未进行词法绑定，所以还不能被访问，此时访问会抛出错误。在这运行流程一进入作用域创建变量，到变量开始可被访问之间的一段时间，就称之为TDZ(暂时死区)。</p>
</li>
<li><pre><code class="javascript">let x = &#39;outer value&#39;

function func () &#123;
  // 这里会产生 TDZ for x
  console.log(x) // TDZ期间访问，产生ReferenceError错误
  let x = &#39;inner value&#39; // 对x的声明语句，这里结束 TDZ for x
&#125;

func()
</code></pre>
</li>
</ul>
</li>
<li><p>不能重复声明</p>
</li>
<li><p>混用<code>var</code>和<code>let</code>，重复声明会报错</p>
</li>
<li><p>全局声明不是window对象的属性</p>
</li>
</ul>
</li>
<li><p><code>const</code></p>
<ul>
<li>声明同时必须初始化</li>
<li>初始化后不能修改</li>
<li>不能修改仅限于常量的引用<ul>
<li>想让整个对象都不能修改，可以使用<code>Object.freeze()</code></li>
</ul>
</li>
<li>不能用于声明会自增的迭代变量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>六种简单数据类型、一种复杂数据类型（Object）。可以使用<code>typeof</code>来确定任意变量的数据类型，它返回一个字符串</p>
<h3 id="Undefined类型"><a href="#Undefined类型" class="headerlink" title="Undefined类型"></a><code>Undefined</code>类型</h3><p>当使用<code>var</code>或<code>let</code>声明了变量但没有初始化时，就相当于给变量赋予了<code>undefined</code>值。在对<strong>未初始化</strong>的变量调用<code>typeof</code>时，返回的结果是<code>&quot;undefined&quot;</code>，但对<strong>未声明</strong>的变量调用它时，返回的结果还是<code>&quot;undefined&quot;</code></p>
<h3 id="Null类型"><a href="#Null类型" class="headerlink" title="Null类型"></a><code>Null</code>类型</h3><p><code>null</code>值表示一个空对象指针，这也是给<code>typeof</code>传一个<code>null</code>会返回<code>&quot;object&quot;</code>的原因。任何时候，只要变量要保存对象，而当时又没有那个对象可保存，就要用<code>null</code>来填充该变量</p>
<h3 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a><code>Boolean</code>类型</h3><p>两个字面量true、false</p>
<p>要将一个其他类型的值转换为布尔值，可以调用特定的<code>Boolean()</code>转型函数，<code>Boolean()</code>转型函数可以在任意类型的数据上调用，而且始终返回一个布尔值。</p>
<p><code>NaN</code>返回<code>false</code></p>
<h3 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a><code>Number</code>类型</h3><ul>
<li>Number类型使用IEEE754格式表示整数和浮点值。</li>
<li>整数也可以用八进制或十六进制字面量表示。如果字面量中包含的数字超出了应有的范围，就会忽略前缀的零，后面的数字序列会被当成十进制数</li>
<li>正零和负零在所有情况下都被认为是等同的</li>
</ul>
<ol>
<li><p>浮点数</p>
<ul>
<li>数值中必须包含小数点，而且小数点后面必须至少有一个数字，没有数字或只有0，则会变成整数</li>
<li>科学计数法，数值（整数或浮点数）后跟一个大写或小写的字母e，再加上一个要乘的10的多少次幂</li>
<li>精度最高达17位小数，算术计算有时会出现偏差，典型例子：<code>0.1+0.2==0.3</code>是false</li>
</ul>
</li>
<li><p>值的范围</p>
<ul>
<li>最小值<ul>
<li><code>Number.MIN_VALUE</code></li>
<li><code>-Infinity</code></li>
<li><code>Number.POSITIVE_INFINITY</code></li>
</ul>
</li>
<li>最大值<ul>
<li><code>Number.MAX_VALUE</code></li>
<li><code>Infinity</code></li>
<li><code>Number.NEGATIVE_INFINITY</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>NaN</code></p>
<blockquote>
<p>不是数值</p>
</blockquote>
<ul>
<li>0、+0、-0相除会返回<code>NaN</code>，任何涉及<code>NaN</code>的操作均返回<code>NaN</code>，<code>NaN</code>不等于包括<code>NaN</code>在内的任何值</li>
<li><code>isNaN()</code>函数。该函数接收一个参数，可以是任意数据类型，然后判断这个参数是否“不是数值”。<ol>
<li>首先会调用对象的<code>valueOf()</code>方法，然后再确定返回的值是否可以转换为数值</li>
<li>如果不能，再调用<code>toString()</code>方法，并测试其返回值</li>
</ol>
</li>
</ul>
</li>
<li><p>数值转换</p>
<ol>
<li><code>Number()</code><ul>
<li>布尔：0、1</li>
<li>数值：返回</li>
<li><code>null</code>：0</li>
<li><code>undefiner</code>：<code>NaN</code></li>
<li>字符串<ul>
<li>正负号+数字字符，转换回十进制数值</li>
<li>字符串前含有十六进制格式（<code>0xf</code>），返回这个十六进制对应的十进制</li>
<li>空字符串：0</li>
<li>其他字符情况：<code>NaN</code></li>
</ul>
</li>
<li>对象<ul>
<li>调用<code>valueOf()</code>方法，再按上述规则转换，如果转换为<code>NaN</code>，则调用<code>toString()</code>方法，再按字符串规则转换</li>
</ul>
</li>
</ul>
</li>
<li><code>parseInt()</code><ul>
<li>如果第一个字符不是数值字符、加号或减号，parseInt()立即返回NaN</li>
<li>如果是，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符</li>
<li>字符串以”0x”开头，就会被解释为十六进制整数</li>
<li>以”0”开头，且紧跟着数值字符，在非严格模式下会被某些实现解释为八进制整数。</li>
<li>parseInt()也接收第二个参数，用于指定底数（进制数）。</li>
</ul>
</li>
<li><code>parseFloat()</code><ul>
<li>与<code>parseInt()</code>函数相似，从位置0开始检测每个字符。同样，它也是解析到字符串末尾或者解析到一个无效的浮点数值字符为止。</li>
<li>始终忽略字符串开头的零</li>
<li>十六进制数值始终会返回0。因为parseFloat()只解析十进制值，因此不能指定底数</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a><code>String</code>类型</h3><p>双引号、单引号、反引号</p>
<ul>
<li>以某种引号作为字符串开头，必须仍然以该种引号作为字符串结尾。</li>
<li>字符串的长度可以通过其<code>length</code>属性获取</li>
<li>字符串是不可变的（immutable），意思是一旦创建，它们的值就不能变了。要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量</li>
<li>字符串值也有<code>toString()</code>方法，该方法只是简单地返回自身的一个副本，<code>null</code>和<code>undefined</code>值没有<code>toString()</code>方法</li>
<li>模板字面量保留反引号内部的空格，可以跨行定义字符串</li>
</ul>
<p>字符串插值</p>
<ul>
<li>模板字面量不是字符串，而是一种特殊的JavaScript句法表达式，只不过求值后得到的是字符串</li>
<li>所有插入的值都会使用<code>toString()</code>强制转型为字符串，而且任何JavaScript表达式都可以用于插值。嵌套的模板字符串无须转义</li>
</ul>
<p>标签函数</p>
<ul>
<li>会接收被插值记号分隔后的模板和对每个表达式求值的结果。</li>
<li>接收到的参数依次是原始字符串数组和对每个表达式求值的结果。</li>
</ul>
<p>原始字符串</p>
<ul>
<li>可以直接获取原始的模板字面量内容（如换行符或Unicode字符），而不是被转换后的字符表示</li>
<li>默认的<code>String.raw</code>标签函数</li>
</ul>
<h3 id="Symbol类型"><a href="#Symbol类型" class="headerlink" title="Symbol类型"></a><code>Symbol</code>类型</h3><blockquote>
<p>符号实例是唯一、不可变的，<strong>用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险</strong>。符号就是用来创建唯一记号，进而用作非字符串形式的对象属性。</p>
</blockquote>
<ul>
<li><p>使用<code>Symbol()</code>函数初始化，可以传入一个字符串参数作为对符号的描述，字符串参数与符号定义或标识完全无关</p>
</li>
<li><p><code>Symbol()</code>函数不能与new关键字一起作为构造函数使用。这样做是为了避免创建符号包装对象</p>
<ul>
<li>确实想使用符号包装对象，可以借用Object()函数</li>
</ul>
</li>
<li><p>全局符号注册表</p>
<ul>
<li><blockquote>
<p>如果运行时的不同部分需要共享和重用符号实例，那么可以用一个字符串作为键，在全局符号注册表中创建并重用符号。</p>
</blockquote>
</li>
<li><p>方法：<code>Symbol.for()</code></p>
<ul>
<li>都执行幂等操作</li>
<li>检查全局运行时注册表，发现不存在对应的符号，于是就会生成一个新符号实例并添加到注册表中。后续使用相同字符串的调用同样会检查注册表，发现存在与该字符串对应的符号，然后就会返回该符号实例。</li>
</ul>
</li>
<li><p>全局注册表中的符号必须使用字符串键来创建，所以参数都会转换成字符串</p>
</li>
<li><p><code>Symbol.keyFor()</code>来查询全局注册表</p>
<ul>
<li>接收符号，返回该全局符号对应的字符串键。如果查询的不是全局符号，则返回<code>undefined</code>。</li>
<li>如果传给<code>Symbol.keyFor()</code>的不是符号，则该方法抛出<code>TypeError</code></li>
</ul>
</li>
<li><p>凡是可以使用字符串或数值作为属性的地方，都可以使用符号</p>
</li>
<li><p><code>Object.getOwnPropertyNames()</code>返回对象实例的常规属性数组</p>
</li>
<li><p><code>Object.getOwnPropertySymbols()</code>返回对象实例的符号属性数组</p>
</li>
<li><p><code>Object.getOwnPropertyDescriptors()</code>会返回同时包含常规和符号属性描述符的对象</p>
</li>
<li><p><code>Reflect.ownKeys()</code>会返回两种类型的键</p>
</li>
</ul>
</li>
</ul>
<h4 id="常用内置符号"><a href="#常用内置符号" class="headerlink" title="常用内置符号"></a>常用内置符号</h4><ol>
<li><code>Symbol.asyncIterator</code><ul>
<li>返回对象默认的<code>AsyncIterator</code>。由<code>for-await-of</code>语句使用</li>
<li>循环时，它们会调用以<code>Symbol.asyncIterator</code>为键的函数，并期望这个函数会返回一个实现迭代器API的对象</li>
</ul>
</li>
<li><code>Symbol.hasInstance</code><ul>
<li>该方法决定一个构造器对象是否认可一个对象是它的实例。由<code>instanceof</code>操作符使用</li>
<li>instanceof操作符可以用来确定一个对象实例的原型链上是否有原型</li>
<li>这个属性定义在Function的原型上</li>
</ul>
</li>
<li><code>Symbol.isConcatSpreadable</code><ol>
<li>数组对象<ul>
<li>默认：打平到已有数组</li>
<li>true：打平到已有数组</li>
<li>false：将整个数组对象追加到数组末尾</li>
</ul>
</li>
<li>类数组对象<ul>
<li>默认：将对象追加到数组末尾</li>
<li>true：打平到已有数组</li>
<li>false：将对象追加到数组末尾</li>
</ul>
</li>
<li>不是数组，也不是类数组<ul>
<li>默认：将对象追加到数组末尾</li>
<li>true：忽略</li>
<li>false：将对象追加到数组末尾</li>
</ul>
</li>
</ol>
</li>
<li><code>Symbol.iterator</code><ul>
<li>该方法返回对象默认的迭代器。由<code>for-of</code>语句使用</li>
</ul>
</li>
<li><code>Symbol.match</code><ul>
<li>用正则表达式去匹配字符串。由<code>String.prototype.match()</code>方法使用</li>
</ul>
</li>
<li><code>Symbol.replace</code><ul>
<li>替换一个字符串中匹配的子串。由<code>String.prototype.replace()</code>方法使用</li>
</ul>
</li>
<li><code>Symbol.search</code><ul>
<li>返回字符串中匹配正则表达式的索引。由<code>String.prototype.search()</code>方法使用</li>
</ul>
</li>
<li><code>Symbol.species</code><ul>
<li>作为创建派生对象的构造函数</li>
<li>用Symbol.species定义静态的获取器（getter）方法，可以覆盖新创建实例的原型定义</li>
</ul>
</li>
<li><code>Symbol.split</code><ul>
<li>该方法在匹配正则表达式的索引位置拆分字符串。由<code>String.prototype.split()</code>方法使用</li>
</ul>
</li>
<li><code>Symbol.toPrimitive</code><ul>
<li>该方法将对象转换为相应的原始值。由<code>ToPrimitive</code>抽象操作使用</li>
</ul>
</li>
<li><code>Symbol.toStringTag</code><ul>
<li>该字符串用于创建对象的默认字符串描述。由内置方法<code>Object.prototype.toString()</code>使用</li>
<li>通过<code>toString()</code>方法获取对象标识时，会检索由<code>Symbol.toStringTag</code>指定的实例标识符，默认为<code>&quot;Object&quot;</code>。内置类型已经指定了这个值，但自定义类实例还需要明确定义</li>
</ul>
</li>
</ol>
<h3 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a><code>Object</code>类型</h3><blockquote>
<p>就是一组数据和功能的集合，通过new操作符后跟对象类型的名称来创建</p>
</blockquote>
<ul>
<li><code>constructor</code><ul>
<li>创建当前对象的函数</li>
</ul>
</li>
<li><code>hasOwnProperty(propertyName)</code><ul>
<li>用于判断当前对象实例上是否存在给定的属性</li>
</ul>
</li>
<li><code>isPrototypeOf(Object)</code><ul>
<li>判断当前对象是否为另一个对象的原型</li>
</ul>
</li>
<li><code>propertyIsEnumerable(propertyName)</code><ul>
<li>判断给定的属性是否可以使用<code>for-in</code>语句枚举</li>
</ul>
</li>
<li><code>toLocaleString()</code><ul>
<li>返回对象的字符串表示，该字符串反映对象所在的本地化执行环境</li>
</ul>
</li>
<li><code>toString()</code><ul>
<li>返回对象的字符串表示</li>
</ul>
</li>
<li><code>valueOf()</code><ul>
<li>返回对象对应的字符串、数值或布尔值表示。通常与<code>toString()</code>的返回值相同。</li>
</ul>
</li>
</ul>
<h2 id="流控制语句"><a href="#流控制语句" class="headerlink" title="流控制语句"></a>流控制语句</h2><ul>
<li><code>if</code></li>
<li><code>do-while</code></li>
<li><code>while</code></li>
<li><code>for</code></li>
<li><code>for-in</code><ul>
<li>用于枚举对象中的非符号键属性</li>
</ul>
</li>
<li><code>for-of</code><ul>
<li>用于遍历可迭代对象的元素</li>
</ul>
</li>
<li>标签语句<ul>
<li>主要用于嵌套循环</li>
<li>和c++的goto差不多</li>
</ul>
</li>
<li><code>break、continue</code></li>
<li><code>switch</code></li>
</ul>
<h2 id="理解函数"><a href="#理解函数" class="headerlink" title="理解函数"></a>理解函数</h2><ul>
<li>function关键字声明，后跟一组参数，然后是函数体</li>
<li>通过函数名来调用函数，要传给函数的参数放在括号里</li>
<li>不需要指定是否返回值。任何函数在任何时间都可以使用return语句来返回函数的值，用法是后跟要返回的值</li>
</ul>
]]></content>
      <categories>
        <category>Javascript高级程序设计</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器与生成器</title>
    <url>/2022/01/08/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<h2 id="理解迭代"><a href="#理解迭代" class="headerlink" title="理解迭代"></a>理解迭代</h2><p>在软件开发领域，“迭代”的意思是按照顺序反复多次执行一段程序，通常会有明确的终止条件</p>
<p>迭代就是循环执行，循环是迭代机制的基础，且迭代会在一个有序集合上进行。</p>
<p>在无迭代器时，迭代有两个缺点</p>
<ul>
<li>迭代之前需要事先知道如何使用数据结构</li>
<li>遍历顺序并不是数据结构固有的</li>
</ul>
<p><code>forEach()</code>方法虽然解决单独记录索引和通过数组对象取得值的问题。不过，没有办法标识迭代何时终止</p>
<span id="more"></span>

<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><blockquote>
<p>开发者无须事先知道如何迭代就能实现迭代操作。</p>
<p>迭代器模式描述了一个方案，即可以把有些结构称为“可迭代对象”（<code>iterable</code>），因为它们实现了正式的<code>Iterable</code>接口，而且可以通过迭代器<code>Iterator</code>消费</p>
</blockquote>
<p>迭代器是一个可以由任意对象实现的接口，支持连续获取对象产出的每一个值。任何实现<code>Iterable</code>接口的对象都有一个<code>Symbol.iterator</code>属性，这个属性引用默认迭代器。默认迭代器就像一个迭代器工厂，也就是一个函数，调用之后会产生一个实现<code>Iterator</code>接口的对象。</p>
<p>可迭代对象</p>
<ul>
<li>包含元素有限</li>
<li>具有无歧义的遍历顺序</li>
</ul>
<p>一个数据结构只要部署了<code>Symbol.iterator</code>属性，就被视为具有<code>iterator</code>接口；调用这个接口，就会返回一个遍历器对象。这样的数据结构才能被称为可迭代对象.</p>
<p>每个迭代器都会关联一个可迭代对象，而迭代器会暴露迭代其关联可迭代对象的API。迭代器无须了解与其关联的可迭代对象的结构，只需要知道如何取得连续的值</p>
<p>实现<code>Iterable</code>接口（可迭代协议）要求同时具备两种能力</p>
<ul>
<li>支持迭代的自我识别能力</li>
<li>创建实现<code>Iterator</code>接口的对象的能力</li>
</ul>
<p>这意味着必须暴露一个属性作为“默认迭代器”，而且这个属性必须使用特殊的<code>Symbol.iterator</code>作为键。这个默认迭代器属性必须引用一个迭代器工厂函数，调用这个工厂函数必须返回一个新迭代器.。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IteratorResult &#123;</span><br><span class="line">  <span class="attr">done</span>: <span class="built_in">boolean</span>;</span><br><span class="line">  value: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Iterator &#123;</span><br><span class="line">  next(): IteratorResult;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Iterable &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator](): Iterator</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际写代码过程中，不需要显式调用<strong>工厂函数</strong>（<code>xxx[Symbol.iterator]</code>）来生成迭代器。实现可迭代协议的所有类型都会自动兼容接收可迭代对象的任何语言特性，原生语言结构会在后台调用提供的可迭代对象的这个工厂函数，从而创建一个迭代器。如果对象原型链上的父类实现了Iterable接口，那这个对象也就实现了这个接口。</p>
<p>迭代器是一种一次性使用的对象，用于迭代与其关联的可迭代对象。迭代器API使用next()方法在可迭代对象中遍历数据</p>
<ul>
<li>成功调用<code>next()</code>，都会返回一个<code>IteratorResult</code>对象<ul>
<li><code>IteratorResult</code>对象包含两个对象：done和value<ul>
<li><code>done</code>是一个布尔值，表示是否还可以再次调用<code>next()</code>取得下一个值</li>
<li><code>value</code>包含可迭代对象的下一个值（<code>done</code>为<code>false</code>），或者<code>undefined</code>（<code>done</code>为<code>true</code>）</li>
</ul>
</li>
</ul>
</li>
<li>若不调用<code>next()</code>，则无法知道迭代器的当前位置</li>
</ul>
<p>迭代器并不知道怎么从可迭代对象中取得下一个值，也不知道可迭代对象有多大。只要迭代器到达<code>done:true</code>状态，后续调用<code>next()</code>就一直返回同样的值了</p>
<p>每个迭代器都表示对可迭代对象的一次性有序遍历。不同迭代器的实例相互之间没有联系，只会独立地遍历可迭代对象</p>
<p>迭代器并不与可迭代对象某个时刻的快照绑定，而仅仅是使用游标来记录遍历可迭代对象的历程。如果可迭代对象在迭代期间被修改了，那么迭代器也会反映相应的变化</p>
<p>迭代器维护着一个指向可迭代对象的引用，因此迭代器会阻止垃圾回收程序回收可迭代对象</p>
<h3 id="自定义迭代器"><a href="#自定义迭代器" class="headerlink" title="自定义迭代器"></a>自定义迭代器</h3><p>与Iterable接口类似，任何实现Iterator接口的对象都可以作为迭代器使用。</p>
<p><code>Symbol.iterator</code>属性引用的工厂函数会返回相同的迭代器</p>
<h3 id="提前终止迭代器"><a href="#提前终止迭代器" class="headerlink" title="提前终止迭代器"></a>提前终止迭代器</h3><p>可选的<code>return()</code>方法用于指定在迭代器<strong>提前关闭</strong>时执行的逻辑。执行迭代的结构在想让迭代器知道它不想遍历到可迭代对象耗尽时，就可以“关闭”迭代器。</p>
<p>可能情形：</p>
<ol>
<li><code>for-of</code>循环通过<code>break</code>、<code>continue</code>、<code>return</code>或<code>throw</code>提前退出</li>
<li>解构操作并未消费所有值</li>
</ol>
<p>如果迭代器没有关闭，则还可以继续从上次离开的地方继续迭代。</p>
<p>因为<code>return()</code>方法是可选的，所以并非所有迭代器都是可关闭的。要知道某个迭代器是否可关闭，可以测试这个迭代器实例的<code>return</code>属性是不是函数对象。仅仅给一个不可关闭的迭代器增加这个方法并不能让它变成可关闭的。这是因为调用<code>return()</code>不会强制迭代器进入关闭状态。即便如此，<code>return()</code>方法还是会被调用</p>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><blockquote>
<p>拥有在一个函数块内暂停和恢复代码执行的能力。使用生成器可以自定义迭代器和实现协程</p>
</blockquote>
<p>生成器的形式是一个函数，函数名称前面加一个星号<code>（*）</code>表示它是一个生成器。只要是可以定义函数的地方，就可以定义生成器。</p>
<p>调用生成器函数会产生一个<strong>生成器对象</strong>。生成器对象一开始处于暂停执行（<code>suspended</code>）的状态，生成器对象也实现了<code>Iterator</code>接口，因此具有<code>next()</code>方法。调用这个方法会让生成器开始或恢复执行</p>
<p>next()方法的返回值类似于迭代器，有一个<code>done</code>属性和一个<code>value</code>属性。函数体为空的生成器函数中间不会停留，调用一次next()就会让生成器到达<code>done:true</code>状态</p>
<p>value属性是生成器函数的返回值，默认值为<code>undefined</code>，可以通过生成器函数的返回值指定</p>
<p>生成器函数</p>
<ul>
<li>只会在初次调用<code>next()</code>方法后开始执行<ul>
<li>初次调用生成器函数并不会打印日志</li>
</ul>
</li>
<li>实现了<code>Iterable</code>接口，它们默认的迭代器是自引用的<ul>
<li><code>g===g[Symbol.iterator]()</code></li>
</ul>
</li>
</ul>
<h3 id="通过yield中断执行"><a href="#通过yield中断执行" class="headerlink" title="通过yield中断执行"></a>通过yield中断执行</h3><blockquote>
<p>yield关键字可以让生成器停止和开始执行，也是生成器最有用的地方。生成器函数在遇到yield关键字之前会正常执行。遇到这个关键字后，执行会停止，函数作用域的状态会被保留。停止执行的生成器函数只能通过在生成器对象上调用next()方法来恢复执行。</p>
</blockquote>
<p>yield关键字</p>
<ul>
<li>有点像函数的中间返回语句<ul>
<li>通过<code>yield</code>关键字退出的生成器函数会处在<code>done:false</code>状态</li>
<li>通过<code>return</code>关键字退出的生成器函数会处于<code>done:true</code>状态</li>
</ul>
</li>
<li>只能在生成器函数内部使用</li>
<li>必须直接位于生成器函数定义中，出现在嵌套的非生成器函数中会抛出语法错误</li>
<li>可以作为函数的中间参数使用<ul>
<li>上一次让生成器函数暂停的yield关键字会接收到传给next()方法的第一个值</li>
<li>第一次调用<code>next()</code>传入的值不会被使用，因为这一次调用是为了开始执行生成器函数</li>
</ul>
</li>
<li><code>yield</code>关键字可以同时用于输入和输出</li>
<li>使用星号增强yield的行为，让它<strong>能够迭代一个可迭代对象</strong>，从而一次产出一个值<ul>
<li><code>yield*</code>最有用的地方是实现递归操作，此时生成器可以产生自身</li>
</ul>
</li>
</ul>
<p>生成器函数内部的执行流程会针对每个生成器对象区分作用域。在一个生成器对象上调用next()不会影响其他生成器</p>
<p>生成器对象作为可迭代对象</p>
<h3 id="提前终止生成器"><a href="#提前终止生成器" class="headerlink" title="提前终止生成器"></a>提前终止生成器</h3><p><code>return()</code>和<code>throw()</code>方法都可以用于强制生成器进入关闭状态</p>
<ol>
<li>所有生成器对象都有<code>return()</code>方法，只要通过它进入关闭状态，就无法恢复了。后续调用<code>next()</code>会显示<code>done:true</code>状态，而提供的任何返回值都不会被存储或传播</li>
<li><code>throw()</code>方法会在暂停的时候将一个提供的错误注入到生成器对象中。如果错误未被处理，生成器就会关闭<ul>
<li>假如生成器函数内部处理了这个错误，那么生成器就不会关闭，而且还可以恢复执行</li>
<li>错误处理会跳过对应的<code>yield</code></li>
<li>如果生成器对象还没有开始执行，那么调用<code>throw()</code>抛出的错误不会在函数内部被捕获，因为这相当于在函数块外部抛出了错误</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Javascript高级程序设计</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>集合引用类型</title>
    <url>/2022/01/08/%E9%9B%86%E5%90%88%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><blockquote>
<p>适合存储和应用程序间交换数据</p>
</blockquote>
<p>创建<code>Object</code>实例方法</p>
<ol>
<li>使用<code>new</code>操作符<code>newObject</code></li>
<li>对象字面量<code>&#123;&#125;</code><ol>
<li>属性名可以是字符串或数值，数值属性会自动转换为字符串</li>
<li>属性名也可以是包含非字母数字字符，但要用中括号去存取</li>
</ol>
</li>
</ol>
<p>属性一般通过点语法获取，也能通过中括号，中括号内使用属性名的字符串形式</p>
<span id="more"></span>

<h2 id="数组与定型数组"><a href="#数组与定型数组" class="headerlink" title="数组与定型数组"></a>数组与定型数组</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h4><ol>
<li>使用<code>Array</code>构造函数<ul>
<li><code>new Array()</code>或<code>Array()</code></li>
<li>可以传入一个数值，然后length属性就会被自动创建并设置为这个值</li>
<li>也可以给Array构造函数传入要保存的元素</li>
</ul>
</li>
<li>数组字面量<ul>
<li><code>[]</code></li>
</ul>
</li>
<li><code>from()</code><ul>
<li>将<strong>类数组结构</strong>转换为数组实例</li>
<li>第一个参数是类数组对象，即任何可迭代的结构，或者有一个<code>length</code>属性和可索引元素的结构</li>
<li>可选第二个参数，映射函数参数。这个函数可以直接增强新数组的值</li>
<li>可选第三个参数，用于指定映射函数中this的值，但这个重写的this值在箭头函数中不适用</li>
</ul>
</li>
<li><code>of()</code><ul>
<li>将<strong>一组参数</strong>转换为数组实例</li>
</ul>
</li>
</ol>
<p>ECMAScript会将逗号之间相应索引位置的值当成空位</p>
<p>数组索引：在中括号中提供的索引表示要访问的值</p>
<ul>
<li>如果索引小于数组包含的元素数，则返回存储在相应位置的元素</li>
<li>如果把一个值设置给超过数组最大索引的索引，则数组长度会自动扩展到该索引值加1</li>
</ul>
<p>通过修改<code>length</code>属性，可以从数组末尾删除或添加元素。</p>
<h4 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h4><ul>
<li>通过<code>instanceof</code>操作符<ul>
<li>缺陷：如果网页里有多个框架，则可能涉及两个不同的全局执行上下文，如果要把数组从一个框架传给另一个框架，则这个数组的构造函数将有别于在第二个框架内本地创建的数组</li>
</ul>
</li>
<li><code>Array.isArray()</code><ul>
<li>确定一个值是否为数组，而不用管它是在哪个全局执行上下文中创建的。</li>
</ul>
</li>
</ul>
<h4 id="迭代器方法"><a href="#迭代器方法" class="headerlink" title="迭代器方法"></a>迭代器方法</h4><ol>
<li><code>keys()</code>：返回数组索引的迭代器</li>
<li><code>values()</code>：返回数组元素的迭代器</li>
<li><code>entries()</code>：返回索引/值对的迭代器</li>
</ol>
<h4 id="复制和填充方法"><a href="#复制和填充方法" class="headerlink" title="复制和填充方法"></a>复制和填充方法</h4><p>两个都不会改变数组大小</p>
<ol>
<li><p>批量复制方法：<code>copyWithin()</code></p>
<ul>
<li>会按照指定范围<strong>浅复制</strong>数组中的部分内容，然后将它们插入到指定索引开始的位置。开始索引和结束索引则与fill()使用同样的计算方法</li>
<li>索引过低、过高、反向都会忽略</li>
</ul>
</li>
<li><p>填充数组方法：<code>fill()</code></p>
<ul>
<li>可以向一个已有的数组中插入全部或部分相同的值</li>
<li>开始索引用于指定开始填充的位置，它是可选的</li>
<li>如果不提供结束索引，则一直填充到数组末尾</li>
<li>负值索引从数组末尾开始计算</li>
<li>参数个数<ul>
<li>1个：<code>fill(x)</code>，用x填充整个数组</li>
<li>2个：<code>fill(x,a)</code>，用x填充索引大于a的元素</li>
<li>3个：<code>fill(x,a,b)</code>，用x填充索引大于a小于b的元素</li>
</ul>
</li>
<li>索引过低、过高、反向都会忽略</li>
</ul>
</li>
</ol>
<h4 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h4><ol>
<li><code>toLocaleString</code><ul>
<li>可能返回跟<code>toString()</code>和<code>valueOf()</code>相同的结果，但也不一定。在调用数组的<code>toLocaleString()</code>方法时，会得到一个逗号分隔的数组值的字符串。它与另外两个方法<strong>唯一的区别</strong>是，为了得到最终的字符串，<strong>会调用数组每个值的toLocaleString()方法，而不是toString()方法</strong></li>
</ul>
</li>
<li><code>toString</code><ul>
<li>返回由数组中每个值的等效字符串拼接而成的一个逗号分隔的<strong>字符串</strong></li>
</ul>
</li>
<li><code>valueOf</code><ul>
<li>返回的还是<strong>数组本身</strong></li>
</ul>
</li>
<li><code>join()</code><ul>
<li>接收一个参数，即字符串分隔符，返回包含所有项的<strong>字符串</strong></li>
<li>如果不传入任何参数，或者传入<code>undefined</code>，则仍然使用逗号作为分隔符</li>
</ul>
</li>
</ol>
<h4 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h4><ol>
<li><code>push()</code></li>
<li><code>pop()</code></li>
</ol>
<h4 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h4><ol>
<li><code>shift()</code><ul>
<li>从数组头取走一个元素</li>
</ul>
</li>
<li><code>unshift()</code><ul>
<li>可添加任意多个值</li>
</ul>
</li>
</ol>
<h4 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a>排序方法</h4><ol>
<li><code>reverse()</code><ul>
<li>将数组元素反向排列</li>
</ul>
</li>
<li><code>sort()</code><ul>
<li>按照升序重新排列数组元素，即最小的值在前面，最大的值在后面</li>
<li>会在每一项上调用<code>String()</code>转型函数，<strong>然后比较字符串来决定顺序</strong></li>
<li>可以接收一个比较函数，用于判断哪个值应该排在前面<ul>
<li>比较函数接收两个参数，如果第一个参数应该排在第二个参数前面，就返回负值；如果两个参数相等，就返回0；如果第一个参数应该排在第二个参数后面，就返回正值。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h4><ol>
<li><p><code>concat()</code></p>
<blockquote>
<p>在现有数组全部元素基础上创建一个新数组</p>
</blockquote>
<ul>
<li>创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组</li>
<li>如果传入一个或多个数组，则<code>concat()</code>会把这些数组的每一项都添加到结果数组</li>
<li>如果参数不是数组，则直接把它们添加到结果数组末尾</li>
</ul>
</li>
<li><p><code>slice()</code></p>
<blockquote>
<p>用于创建一个包含原有数组中一个或多个元素的新数组</p>
</blockquote>
<ul>
<li>接收一个或两个参数：返回元素的开始索引和结束索引</li>
<li>如果只有一个参数，则<code>slice()</code>会返回该索引到数组末尾的所有元素</li>
<li>如果有两个参数，则<code>slice()</code>返回从开始索引到结束索引对应的所有元素</li>
<li>操作不影响原始数组</li>
</ul>
</li>
<li><p><code>splice()</code></p>
<blockquote>
<p>主要目的是在数组中间插入元素</p>
</blockquote>
<ul>
<li>删除：传2个参数：要删除的第一个元素的位置和要删除的元素数量</li>
<li>插入：传3个参数：开始位置、0（要删除的元素数量）和要插入的元素</li>
<li>替换：传入3个参数：开始位置、要删除元素的数量和要插入的任意多个元素</li>
</ul>
</li>
</ol>
<h4 id="搜索和位置方法"><a href="#搜索和位置方法" class="headerlink" title="搜索和位置方法"></a>搜索和位置方法</h4><p>两种分类：按严格相等搜索和按断言函数搜索</p>
<ol>
<li><p>严格相等搜索，这些方法都接收两个参数：要查找的元素和一个可选的起始搜索位置</p>
<ol>
<li><code>indexOf()</code><ul>
<li>从数组前头（第一项）开始向后搜索</li>
<li>返回要查找的元素在数组中的位置，如果没找到则返回1</li>
</ul>
</li>
<li><code>lastIndexOf()</code><ul>
<li>从数组末尾（最后一项）开始向前搜索</li>
<li>返回要查找的元素在数组中的位置，如果没找到则返回1</li>
</ul>
</li>
<li><code>includes()</code><ul>
<li><p>从数组前头（第一项）开始向后搜索</p>
</li>
<li><p>返回布尔值</p>
</li>
<li><p>能正确处理<code>NaN</code></p>
<ul>
<li><pre><code class="javascript">constarr=[NaN];
console.log(arr.indexOf(NaN)) //-1
console.log(arr.includes(NaN))//true
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><p>断言函数搜索</p>
<blockquote>
<p>每个索引都会调用这个函数。断言函数的返回值决定了相应索引的元素是否被认为匹配</p>
</blockquote>
<ul>
<li>第一个参数是函数，此函数接受三个参数：元素、索引和数组本身，都从数组的最小索引开始</li>
<li>可选第二个参数，用于指定断言函数内部this的值</li>
</ul>
<ol>
<li><code>find()</code><ul>
<li>返回第一个匹配的元素</li>
</ul>
</li>
<li><code>findIndex()</code><ul>
<li>返回第一个匹配元素的索引</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h4><blockquote>
<p>每个方法接收两个参数：以每一项为参数运行的函数，以及可选的作为函数运行上下文的作用域对象，传给每个方法的函数接收3个参数：数组元素、元素索引和数组本身。</p>
</blockquote>
<ol>
<li><code>every()</code><ul>
<li>对每一项函数都返回<code>true</code>，则这个方法返回<code>true</code></li>
</ul>
</li>
<li><code>filter()</code><ul>
<li>返回<code>true</code>的项会组成数组之后返回</li>
<li>非常适合从数组中筛选满足给定条件的元素</li>
</ul>
</li>
<li><code>forEach()</code><ul>
<li>每一项都运行传入的函数，没有返回值</li>
<li>相当于使用<code>for</code>循环遍历数组</li>
</ul>
</li>
<li><code>map()</code><ul>
<li>返回由每次函数调用的结果构成的数组</li>
</ul>
</li>
<li><code>some()</code><ul>
<li>如果有一项函数返回<code>true</code>，则这个方法返回<code>true</code>。</li>
</ul>
</li>
</ol>
<h4 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h4><blockquote>
<p>会迭代数组的所有项，并在此基础上构建一个最终返回值</p>
</blockquote>
<ol>
<li><code>reduce()</code><ul>
<li>从数组第一项开始遍历到最后一项</li>
<li>可接受两个参数<ul>
<li>第一个参数，是个归并函数，此函数包含四个参数：上一个归并值、当前项、当前项的索引和数组本身</li>
<li>第二个参数可选，以之为归并起点的初始值，不选则归并函数的第一个参数是数组的第一项，第二个参数是数组的第二项</li>
</ul>
</li>
</ul>
</li>
<li><code>reduceRight()</code><ul>
<li>从最后一项开始遍历至第一项</li>
<li>同上</li>
</ul>
</li>
</ol>
<h2 id="Map、WeakMap、Set以及WeakSet类型"><a href="#Map、WeakMap、Set以及WeakSet类型" class="headerlink" title="Map、WeakMap、Set以及WeakSet类型"></a>Map、WeakMap、Set以及WeakSet类型</h2><p>Map的大多数特性都可以通过Object类型实现，但二者之间还是存在一些细微的差异</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>与<code>Object</code>只能使用数值、字符串或符号作为键不同，<code>Map</code>可以使用任何JavaScript数据类型作为键，内部使用严格相等的标准来检测键的匹配性。与<code>Object</code>类似，映射的值是没有限制</p>
<h4 id="基本API"><a href="#基本API" class="headerlink" title="基本API"></a>基本API</h4><ol>
<li><code>newMap()</code>：使用<code>new</code>关键字和<code>Map</code>构造函数创建一个空映射<ul>
<li>可以传入一个可迭代对象，需要包含键/值对数组，且会按照迭代顺序插入到新映射实例</li>
</ul>
</li>
<li><code>set()</code></li>
<li><code>get()</code></li>
<li><code>has()</code></li>
<li><code>delete()</code></li>
<li><code>clear()</code></li>
</ol>
<h4 id="顺序与迭代"><a href="#顺序与迭代" class="headerlink" title="顺序与迭代"></a>顺序与迭代</h4><ul>
<li>可以通过<code>entries()</code>方法（或者<code>Symbol.iterator</code>属性，它引用<code>entries()</code>）取得这个迭代器。因为<code>entries()</code>是默认迭代器，所以可以直接对映射实例使用扩展操作，把映射转换为数组</li>
<li>可以调用映射的<code>forEach(callback,opt_thisArg)</code>方法并传入回调，依次迭代每个键/值对<ul>
<li>传入的回调接收可选的第二个参数，这个参数用于重写回调内部this的值</li>
</ul>
</li>
<li><code>keys()</code>和<code>values()</code>分别返回以插入顺序生成键和值的迭代器</li>
<li>键和值在迭代器遍历时是可以修改的，但映射内部的引用则无法修改</li>
</ul>
<h4 id="Object与Map的比较"><a href="#Object与Map的比较" class="headerlink" title="Object与Map的比较"></a><code>Object</code>与<code>Map</code>的比较</h4><ol>
<li>内容占用<ul>
<li>存储单个键/值对所占用的内存数量都会随键的数量线性增加</li>
<li>给定固定大小的内存，<code>Map</code>大约可以比<code>Object</code>多存储50%的键/值对</li>
</ul>
</li>
<li>插入性能<ul>
<li>插入新键/值对的消耗大致相当</li>
<li>插入速度并不会随着键/值对数量而线性增加</li>
<li>大量插入操作，那么显然Map的性能更佳</li>
</ul>
</li>
<li>查找速度<ul>
<li>性能差异极小</li>
<li>查找速度不会随着键/值对数量增加而线性增加</li>
<li>涉及大量查找操作，那么某些情况下可能选择Object更好一些</li>
</ul>
</li>
<li>删除性能<ul>
<li>Map的delete()操作都比插入和查找更快</li>
<li>涉及大量删除操作，那么毫无疑问应该选择Map</li>
</ul>
</li>
</ol>
<h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><ul>
<li>弱映射中的键只能是Object或者继承自Object的类型，尝试使用非对象设置键会抛出TypeError。值的类型没有限制。</li>
<li>没有指向这个对象(键)的其他引用-&gt;键就会被当作垃圾回收-&gt;键值对从弱映射消失，成为空映射-&gt;值就没了引用-&gt;所以值就可以被当作垃圾进行回收</li>
<li>因为WeakMap中的键/值对任何时候都可能被销毁，所以没必要提供迭代其键/值对的能力</li>
<li>WeakMap实例之所以限制只能用对象作为键，是为了保证只有通过键对象的引用才能取得值</li>
</ul>
<h4 id="基本API-1"><a href="#基本API-1" class="headerlink" title="基本API"></a>基本API</h4><ol>
<li><code>newWeakMap()</code><ul>
<li>可以传入一个可迭代对象，需要包含键/值对数组，且会按照迭代顺序插入到新映射实例</li>
<li>初始化是全有或全无的操作，只要有一个键无效就会抛出错误，导致整个初始化失败</li>
</ul>
</li>
<li><code>set()</code></li>
<li><code>get()</code></li>
<li><code>has()</code></li>
<li><code>delete()</code></li>
</ol>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ol>
<li>私有变量</li>
<li>DOM节点元数据</li>
</ol>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p><code>Set</code>可以包含任何JavaScript数据类型作为值</p>
<h4 id="基本API-2"><a href="#基本API-2" class="headerlink" title="基本API"></a>基本API</h4><ol>
<li><code>newSet()</code>：使用<code>new</code>关键字和<code>Set</code>构造函数创建一个空集合<ul>
<li>可以传入一个可迭代对象</li>
</ul>
</li>
<li><code>add()</code></li>
<li><code>has()</code></li>
<li><code>delete()</code><ul>
<li>返回一个布尔值，表示集合中是否存在要删除的值</li>
</ul>
</li>
<li><code>clear()</code></li>
</ol>
<h4 id="顺序与迭代-1"><a href="#顺序与迭代-1" class="headerlink" title="顺序与迭代"></a>顺序与迭代</h4><p>Set会维护值插入时的顺序，因此支持按顺序迭代。</p>
<ul>
<li>可以提供一个迭代器（<code>Iterator</code>），能以插入顺序生成集合内容。可以通过<code>values()</code>方法及其别名方法<code>keys()</code>（或者<code>Symbol.iterator</code>属性，它引用<code>values()</code>）取得这个迭代器</li>
<li>因为<code>values()</code>是默认迭代器，所以可以直接对集合实例使用扩展操作，把集合转换为数组</li>
<li>集合的<code>entries()</code>方法返回一个迭代器，可以按照插入顺序产生包含两个元素的数组，这两个元素是集合中每个值的重复出现</li>
<li>如果不使用迭代器，而是使用回调方式，则可以调用集合的<code>forEach()</code>方法并传入回调，依次迭代每个键/值对。传入的回调接收可选的第二个参数，这个参数用于重写回调内部<code>this</code>的值</li>
</ul>
<h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p>弱集合中的值只能是<code>Object</code>或者继承自<code>Object</code>的类型，尝试使用非对象设置值会抛出<code>TypeError</code>。</p>
<p>当没有指向这个对象的其他引用-&gt;这个对象值就会被当作垃圾回收-&gt;这个值就从弱集合中消失了，成为空集合。</p>
<p>WeakSet之所以限制只能用对象作为值，是为了保证只有通过值对象的引用才能取得值。</p>
<h4 id="基本API-3"><a href="#基本API-3" class="headerlink" title="基本API"></a>基本API</h4><ol>
<li><code>newWeakSet()</code><ul>
<li>可以传入一个可迭代对象</li>
<li>初始化是全有或全无的操作，只要有一个值无效就会抛出错误，导致整个初始化失败</li>
</ul>
</li>
<li><code>add()</code></li>
<li><code>has()</code></li>
<li><code>delete()</code><ul>
<li>返回一个布尔值，表示集合中是否存在要删除的值</li>
</ul>
</li>
</ol>
<h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>打标签</li>
</ul>
<h3 id="迭代与扩展操作"><a href="#迭代与扩展操作" class="headerlink" title="迭代与扩展操作"></a>迭代与扩展操作</h3><p><code>Array</code>、所有定型数组、<code>Map</code>、<code>Set</code></p>
<ul>
<li>都定义了默认迭代器</li>
<li>都支持顺序迭代，都可以传入<code>for-of</code>循环</li>
<li>都兼容扩展操作符。扩展操作符在对可迭代对象执行浅复制时特别有用<ul>
<li>浅复制意味着只会复制对象引用</li>
</ul>
</li>
<li>对于期待可迭代对象的构造函数，只要传入一个可迭代对象就可以实现复制</li>
</ul>
]]></content>
      <categories>
        <category>Javascript高级程序设计</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>对象、类与面向对象编程</title>
    <url>/2022/01/09/%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h2><blockquote>
<p>一组属性的无序集合，每个属性或方法都由一个名称来标识，这个名称映射到一个值</p>
<p>可以想象成一张散列表，其中的内容就是一组名/值对，值可以是数据或者函数</p>
</blockquote>
<p>创建方法</p>
<ol>
<li><code>new Object()</code>然后再给它添加属性和方法</li>
<li><code>&#123;&#125;</code>对象字面量</li>
</ol>
<span id="more"></span>

<p>内部属性，（不能在js直接访问）</p>
<ol>
<li>数据属性<ul>
<li>[[Configurable]]<ul>
<li>是否可以通过delete删除并重新定义</li>
<li>是否可以修改它的特性</li>
<li>是否可以改为访问器属性</li>
<li>默认为true</li>
</ul>
</li>
<li>[[Enumerable]]<ul>
<li>是否可以通过for-in循环返回</li>
<li>默认为true</li>
</ul>
</li>
<li>[[Writable]]<ul>
<li>是否可以被修改</li>
<li>默认为true</li>
</ul>
</li>
<li>[[Value]]<ul>
<li>包含属性实际的值</li>
<li>默认undefined</li>
</ul>
</li>
</ul>
</li>
<li>访问器属性<ul>
<li>[[Configurable]]<ul>
<li>是否可以通过delete删除并重新定义</li>
<li>是否可以修改它的特性</li>
<li>是否可以改为数据属性</li>
<li>默认为true</li>
</ul>
</li>
<li>[[Enumerable]]<ul>
<li>是否可以通过for-in循环返回</li>
<li>默认为true</li>
</ul>
</li>
<li>[[Get]]<ul>
<li>获取函数，在读取属性时调用。默认值为undefined。</li>
</ul>
</li>
<li>[[Set]]<ul>
<li>设置函数，在写入属性时调用。默认值为undefined</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><ol>
<li><code>Object.defineProperty()</code><ul>
<li>接收3个参数：要给其添加属性的对象、属性的名称和一个描述符对象</li>
<li>configurable、enumerable和writable的值如果不指定，则都默认为false</li>
</ul>
</li>
<li>Object.defineProperties()<ul>
<li>这个方法可以通过多个描述符一次性定义多个属性</li>
<li>接收两个参数：要为之添加或修改属性的对象和另一个描述符对象</li>
</ul>
</li>
<li>Object.getOwnPropertyDescriptor()<ul>
<li>取得指定属性的属性描述符</li>
<li>接收两个参数：属性所在的对象和要取得其描述符的属性名。返回值是一个对象</li>
</ul>
</li>
<li>Object.getOwnPropertyDescriptors()<ul>
<li>实际上会在每个自有属性上调用Object.getOwnPropertyDescriptor()并在一个新对象中返回它们</li>
<li>接受一个参数，参数为对象</li>
</ul>
</li>
<li>Object.assign()<ul>
<li>用于合并对象，是<strong>浅复制</strong>，接收一个目标对象和一个或多个源对象作为参数</li>
<li>可枚举和自有属性才复制到目标对象</li>
<li>这个方法会使用源对象上的[[Get]]取得属性的值，然后使用目标对象上的[[Set]]设置属性的值</li>
</ul>
</li>
<li>Object.is()<ul>
<li>与===很像，接受两个参数</li>
</ul>
</li>
<li>isPrototypeOf()<ul>
<li>确定两个对象之间的关系，只要原型链中包含这个原型，这个方法就返回true</li>
</ul>
</li>
<li>Object.getPrototypeOf()<ul>
<li>返回参数的内部特性[[Prototype]]的值</li>
</ul>
</li>
<li>Object.setPrototypeOf()<ul>
<li>可以向实例的私有特性[[Prototype]]写入一个新值。这样就可以重写一个对象的原型继承关系</li>
<li>例子：Object.setPrototypeOf(A,B)，A的原型就指向B</li>
</ul>
</li>
<li>Object.create()</li>
</ol>
<ul>
<li>创建一个新对象，同时为其指定原型</li>
<li>参数两个<ul>
<li>第一个：作为新对象原型的对象</li>
<li>第二个可选：给新对象定义额外属性的对象，Object.defineProperties()的第二个参数一样：每个新增属性都通过各自的描述符来描述。以这种方式添加的属性会遮蔽原型对象上的同名属性</li>
</ul>
</li>
</ul>
<ol start="11">
<li>hasOwnProperty()<ul>
<li>用于确定某个属性是在实例上还是在原型对象上。这个方法是继承自Object的，会在属性存在于调用它的对象实例上时返回true</li>
</ul>
</li>
<li>Object.getOwnPropertySymbol()<ul>
<li>取得以symbol为键的值，返回的是数组</li>
<li>与Object.getOwnPropertyNames()类似，只是针对符号而已</li>
</ul>
</li>
</ol>
<p>增强的对象语法</p>
<ol>
<li>属性简写<ul>
<li>只要使用变量名（不用再写冒号）就会自动被解释为同名的属性键</li>
<li>如果没有找到同名变量，则会抛出ReferenceError</li>
</ul>
</li>
<li>可计算属性<ul>
<li>可以在对象字面量中完成动态属性赋值。中括号内被当作JavaScript表达式求值</li>
<li>抛出任何错误都会中断对象创建</li>
</ul>
</li>
<li>简写方法名</li>
</ol>
<p>对象解构</p>
<ul>
<li>就是使用与对象匹配的结构来实现对象属性赋值</li>
<li>解构在内部使用函数ToObject()（不能在运行时环境中直接访问）把源数据结构转换为对象</li>
<li>null和undefined不能被解构，否则会抛出错误</li>
<li>解构并不要求变量必须在解构表达式中声明。不过，如果是给事先声明的变量赋值，则赋值表达式必须包含在一对括号中</li>
<li>解构赋值可以使用嵌套结构，以匹配嵌套的属性</li>
<li>一个解构表达式涉及多个赋值，开始的赋值成功而后面的赋值出错，则整个解构赋值只会完成一部分</li>
</ul>
<h2 id="理解对象创建过程"><a href="#理解对象创建过程" class="headerlink" title="理解对象创建过程"></a>理解对象创建过程</h2><p>缺陷：虽然使用Object构造函数或对象字面量可以方便地创建对象，但这些方式也有明显不足：创建具有同样接口的多个对象需要重复编写很多代码</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><blockquote>
<p>用于抽象创建特定对象的过程</p>
<p>工厂模式虽然可以解决创建多个类似对象的问题，但没有解决对象标识问题</p>
</blockquote>
<p>有一个函数，传入参数给它，它在里面<strong>新建对象</strong>。并用参数完成赋值，再把对象返回出去。这个函数就叫做工厂函数。</p>
<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><p>有一个函数，传入参数给它，属性和方法直接赋值给了<code>this</code>。</p>
<p>与工厂函数区别</p>
<ul>
<li>没有显式地创建对象</li>
<li>属性和方法直接赋值给了<code>this</code></li>
<li>没有<code>return</code></li>
</ul>
<p>用<code>new</code>操作符创建实例，会发生以下事情</p>
<ul>
<li>在内存中创建一个新对象</li>
<li>这个新对象内部的<code>[[Prototype]]</code>特性被赋值为构造函数的<code>prototype</code>属性</li>
<li>构造函数内部的this被赋值为这个新对象（即this指向新对象）</li>
<li>执行构造函数内部的代码（给新对象添加属性）。</li>
<li>如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。</li>
</ul>
<p>实例有<code>constructor</code>属性，<strong>指向构造函数</strong></p>
<ul>
<li><code>constructor</code>本来是用于标识对象类型的</li>
<li>定义自定义构造函数可以确保实例被标识为特定类型</li>
</ul>
<p>在调用一个函数而没有明确设置this值的情况下（即没有作为对象的方法调用，或者没有使用<code>call()/apply()</code>调用），<code>this</code>始终指向<code>Global</code>对象。</p>
<p>构造函数问题：其定义的方法会在每个实例上都创建一遍，自定义类型引用的代码不能很好地聚集一起。</p>
<p>此问题可以通过原型模式解决。</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>每个函数都会创建一个<code>prototype</code>属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。这个对象就是通过调用构造函数创建的对象的原型。使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。</p>
<h4 id="理解原型"><a href="#理解原型" class="headerlink" title="理解原型"></a>理解原型</h4><p>无论何时，只要创建一个函数，就会按照特定的规则为这个函数创建一个<code>prototype</code>属性（指向原型对象）。所有原型对象自动获得一个名为<code>constructor</code>的属性，指回与之关联的构造函数。</p>
<p>每次调用构造函数创建一个新实例，这个实例的内部<code>[[Prototype]]</code>指针就会被赋值为构造函数的原型对象。脚本中没有访问这个<code>[[Prototype]]</code>特性的标准方式，但Firefox、Safari和Chrome会在每个对象上暴露<code>__proto__</code>属性，通过这个属性可以访问对象的原型。实例与构造函数原型之间有直接的联系，但实例与构造函数之间没有。</p>
<p>实例、构造函数、原型对象三者关系</p>
<ul>
<li>构造函数有一个<code>prototype</code>属性。指向原型对象</li>
<li>原型对象有一个<code>constructor</code>的属性，指回构造函数</li>
<li>实例有一个内部<code>[[Prototype]]</code>指针，指着原型对象，可以用<code>__proto__</code>属性可以访问原型对象</li>
<li>实例还有一个<code>constructor</code>属性，指向构造函数</li>
<li>实例可以获取原型对象的属性，但修改不来原型对象的属性</li>
</ul>
<h4 id="原型和in操作符"><a href="#原型和in操作符" class="headerlink" title="原型和in操作符"></a>原型和in操作符</h4><ul>
<li><code>in</code>操作符会在可以通过对象访问指定属性时返回<code>true</code>，无论该属性是<strong>在实例上还是在原型上</strong><ul>
<li>在<code>for-in</code>循环中使用in操作符时，可以通过对象访问且可以被枚举的属性都会返回，包括实例属性和原型属性</li>
</ul>
</li>
<li><code>Object.keys()</code>方法。这个方法接收一个对象作为参数，返回包含该对象所有可枚举属性名称的字符串数组</li>
</ul>
<h4 id="属性枚举顺序"><a href="#属性枚举顺序" class="headerlink" title="属性枚举顺序"></a>属性枚举顺序</h4><p><code>Object.getOwnPropertyNames()</code>、<code>Object.getOwnPropertySymbols()</code>和<code>Object.assign()</code>的枚举顺序是确定性的。先以升序枚举数值键，然后以插入顺序枚举字符串和符号键</p>
<h3 id="对象迭代"><a href="#对象迭代" class="headerlink" title="对象迭代"></a>对象迭代</h3><p><code>Object.values()</code>和<code>Object.entries()</code>接收一个对象，返回它们内容的数组。<code>Object.values()</code>返回对象值的数组，<code>Object.entries()</code>返回键/值对的数组。</p>
<p>直接用对象字面量重写原型对象，会丢失<code>constructor</code>属性，需要手动加上，并且要设置<code>[[Enumerable]]</code>为<code>false</code></p>
<p>原型的动态性</p>
<ul>
<li>任何时候对原型对象所做的修改也会在实例上反映出来</li>
<li>因为实例和原型之间的链接就是简单的指针</li>
<li>如果重写原型，会切断最初原型与构造函数的联系，但实例引用的仍然是最初的原型</li>
<li>实例只有指向原型的指针，没有指向构造函数的指针</li>
</ul>
<h4 id="原型问题"><a href="#原型问题" class="headerlink" title="原型问题"></a>原型问题</h4><ul>
<li>弱化了向构造函数传递初始化参数的能力，会导致所有实例默认都取得相同的属性值</li>
<li>最主要问题源自它的共享特性<ul>
<li>对函数没问题，但对属性就有问题了，例如引用值被共享，一个实例修改了，另一个实例也会被修改。</li>
</ul>
</li>
</ul>
<p>应该不同的实例应该有属于自己的属性副本</p>
<h2 id="理解继承"><a href="#理解继承" class="headerlink" title="理解继承"></a>理解继承</h2><blockquote>
<p>JavaScript只有实现继承，继承实际方法，主要通过原型链实现</p>
</blockquote>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><blockquote>
<p>基本思想就是通过原型继承多个引用类型的属性和方法</p>
</blockquote>
<p>原型链的由来，如果一个原型是另一个类型的实例，意味着这个原型本身有个一内部指针指着另一个原型，相应的另一个原型也有一个指针指向另一个构造函数，这样，实例和原型之间构造了一条原型链。</p>
<h4 id="默认原型"><a href="#默认原型" class="headerlink" title="默认原型"></a>默认原型</h4><p>默认情况下，所有引用类型都继承自Object，这也是通过原型链实现的。任何函数的默认原型都是一个Object的实例</p>
<h4 id="原型与继承关系"><a href="#原型与继承关系" class="headerlink" title="原型与继承关系"></a>原型与继承关系</h4><ul>
<li><code>instanceof</code>操作符</li>
<li><code>isPrototypeOf()</code>方法<ul>
<li>只要原型链中包含这个原型，这个方法就返回<code>true</code></li>
</ul>
</li>
</ul>
<h4 id="关于方法"><a href="#关于方法" class="headerlink" title="关于方法"></a>关于方法</h4><p>子类有时候需要覆盖父类的方法，或者增加父类没有的方法。为此，这些方法必须在原型赋值之后再添加到原型上</p>
<p>以对象字面量方式创建原型方法会破坏之前的原型链，因为这相当于重写了原型链。</p>
<h4 id="原型链问题"><a href="#原型链问题" class="headerlink" title="原型链问题"></a>原型链问题</h4><ul>
<li>原型中包含的引用值会在所有实例间共享，这也是为什么属性通常会在构造函数中定义而不会定义在原型上的原因</li>
<li>子类型在实例化时不能给父类型的构造函数传参</li>
</ul>
<h3 id="盗用构造函数"><a href="#盗用构造函数" class="headerlink" title="盗用构造函数"></a>盗用构造函数</h3><blockquote>
<p>基本思路很简单：在子类构造函数中调用父类构造函数。所以可以使用<code>apply()</code>和<code>call()</code>方法以新创建的对象为上下文执行构造函数</p>
</blockquote>
<p>优点</p>
<ul>
<li>可以在子类构造函数中向父类构造函数传参</li>
</ul>
<p>问题</p>
<ul>
<li>必须在构造函数中定义方法，因此函数不能重用</li>
<li>子类也不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式</li>
</ul>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><blockquote>
<p>综合了原型链和盗用构造函数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性</p>
</blockquote>
<p>优点</p>
<ul>
<li>实例都有自己的属性，并且还共享相同的方法<ul>
<li>属性定义在构造函数，方法放到原型上</li>
</ul>
</li>
<li>保留了<code>instanceof</code>操作符和<code>isPrototypeOf()</code>方法识别合成对象的能力</li>
</ul>
<p>缺点</p>
<ul>
<li>最主要的效率问题就是父类构造函数始终会被调用两次<ul>
<li>一次在是<strong>创建子类原型时</strong>调用</li>
<li>另一次是在<strong>子类构造函数中</strong>调用</li>
</ul>
</li>
</ul>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><blockquote>
<p>即使不自定义类型也可以通过原型实现对象之间的信息共享</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用场景：你有一个对象，想在它的基础上再创建一个新对象。你需要把这个对象先传给<code>object()</code>，然后再对返回的对象进行适当修改。</p>
<p><code>Object.create()</code>方法在只有一个参数时，与这里的object()方法效果相同</p>
<p>原型式继承非常适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合</p>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><blockquote>
<p>思路类似于寄生构造函数和工厂模式：创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> clone = object(original); <span class="comment">// 通过调用函数创建一个新对象</span></span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;	<span class="comment">// 以某种方式增强这个对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> clone; <span class="comment">// 返回这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似。</p>
<h3 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h3><blockquote>
<p>寄生式组合继承通过盗用构造函数继承属性，但使用混合式原型链继承方法。基本思路是<strong>不通过调用父类构造函数给子类原型赋值</strong>，而是取得父类原型的一个副本。说到底就是使用寄生式继承来继承父类原型，然后将返回的新对象赋值给子类原型</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> prototype = object(superType.prototype); <span class="comment">// 创建对象</span></span><br><span class="line">  prototype.constructor = subType; <span class="comment">// 增强对象</span></span><br><span class="line">  subType.prototype = prototype; <span class="comment">// 赋值对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数核心逻辑</p>
<ul>
<li>接受两个参数<ul>
<li>子类构造函数</li>
<li>父类构造函数</li>
</ul>
</li>
<li>创建父类原型的一个副本</li>
<li>返回的<code>prototype</code>对象设置<code>constructor</code>属性，解决由于重写原型导致默认<code>constructor</code>丢失的问题</li>
<li>将新创建的对象赋值给子类型的原型</li>
</ul>
<p>寄生式组合继承可以算是引用类型继承的最佳模式</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。</p>
<p>（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。</p>
<p>（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。</p>
<p>（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5中定义的<code>Object.create()</code>方法就是原型式继承的实现。缺点与原型链方式相同。</p>
<p>（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。</p>
<p>（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。</p>
</blockquote>
<h2 id="理解类"><a href="#理解类" class="headerlink" title="理解类"></a>理解类</h2><p>定义类</p>
<ol>
<li>类声明</li>
<li>类表达式</li>
</ol>
<p>类</p>
<ul>
<li>表达式在它们被求值前也不能引用</li>
<li>类声明不能提升</li>
<li>受块级作用域限制</li>
<li>可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法，但这些都不是必需的</li>
<li>可以通过<code>name</code>属性取得类表达式的名称字符串。但不能在类表达式作用域外部访问这个标识符</li>
<li>可以像函数一样在任何地方定义</li>
<li>也可以立即实例化</li>
</ul>
<h3 id="类构造函数"><a href="#类构造函数" class="headerlink" title="类构造函数"></a>类构造函数</h3><p><code>constructor</code>关键字用于在类定义块内部创建类的构造函数。方法名constructor会告诉解释器在使用<code>new</code>操作符创建类的新实例时，应该调用这个函数</p>
<p>使用<code>new</code>调用类的构造函数会执行如下操作：</p>
<ul>
<li>在内存中创建一个新对象。</li>
<li>这个新对象内部的<code>[[Prototype]]</code>指针被赋值为构造函数的<code>prototype</code>属性。</li>
<li>构造函数内部的<code>this</code>被赋值为这个新对象（即<code>this</code>指向新对象）。</li>
<li>执行构造函数内部的代码（给新对象添加属性）。</li>
<li>如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象</li>
</ul>
<p>默认情况下，类构造函数会在执行之后<strong>返回<code>this</code>对象</strong>。构造函数返回的对象会被用作实例化的对象，如果没有什么引用新创建的<code>this</code>对象，那么这个对象会被销毁。不过，如果返回的不是this对象，而是其他对象，那么这个对象不会通过<code>instanceof</code>操作符检测出跟类有关联，因为这个对象的原型指针并没有被修改。</p>
<p>类构造函数与构造函数的主要区别：</p>
<ul>
<li>调用类构造函数必须使用<code>new</code>操作符</li>
<li>而普通构造函数如果不使用<code>new</code>调用，那么就会以全局的<code>this</code>（通常是<code>window</code>）作为内部对象</li>
<li>调用类构造函数时如果忘了使用<code>new</code>则会抛出错误</li>
</ul>
<p>可以使用<code>instanceof</code>操作符检查一个对象与类构造函数，以确定这个对象是不是类的实例</p>
<p>类中定义的<code>constructor</code>方法不会被当成构造函数，在对它使用<code>instanceof</code>操作符时会返回<code>false</code>。但是，如果在创建实例时直接将类构造函数当成普通构造函数来使用，那么<code>instanceof</code>操作符的返回值会反转</p>
<h3 id="实例、原型和类成员"><a href="#实例、原型和类成员" class="headerlink" title="实例、原型和类成员"></a>实例、原型和类成员</h3><ol>
<li><p>实例成员</p>
<ul>
<li><p>每次通过<code>new</code>调用类标识符时，都会执行类构造函数，在这个函数内部，可以为新创建的实例（<code>this</code>）添加“自有”属性</p>
</li>
<li><p>放在<strong>构造函数</strong>的方法是各自独立的，放在<strong>构造函数外类块中</strong>的方法（即为原型方法）可以共享。</p>
</li>
</ul>
</li>
<li><p>原型方法与访问器</p>
<ul>
<li><p>方法可以定义在类构造函数中或者类块中，但不能在类块中给原型添加原始值或对象作为成员数据</p>
</li>
<li><p>类方法等同于对象属性，因此可以使用字符串、符号或计算的值作为键</p>
</li>
<li><p>类定义也支持获取和设置访问器</p>
</li>
</ul>
</li>
<li><p>静态类方法</p>
<ul>
<li>使用static关键字作为前缀，在静态成员中，**<code>this</code>引用类自身**。</li>
<li>通常用于执行不特定于实例的操作，也不要求存在类的实例</li>
<li>与原型成员类似，静态成员每个类上只能有一个。</li>
<li>静态类方法非常适合作为实例工厂</li>
</ul>
</li>
<li><p>非函数原型和类成员</p>
<ul>
<li>类定义并不显式支持在原型或类上添加成员数据，但在类定义外部，可以手动添加</li>
</ul>
</li>
<li><p>迭代器与生成器方法</p>
<ul>
<li>类定义语法支持在原型和类本身上定义生成器方法</li>
<li>因为支持生成器方法，所以可以通过添加一个默认的迭代器，把类实例变成可迭代对象</li>
</ul>
</li>
</ol>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><blockquote>
<p>背后依旧使用的原型链</p>
</blockquote>
<ol>
<li><p>继承基础</p>
<p>支持<strong>单继承</strong>，使用<code>extends</code>关键字，可以继承任何拥有<code>[[Construct]]</code>和原型的对象，不仅可以继承一个类，也可以继承普通的构造函数</p>
<p>派生类都会通过原型链访问到类和原型上定义的方法。this的值会反映调用相应方法的实例或者类</p>
</li>
<li><p>构造函数、<code>HomeObject</code>和<code>super()</code></p>
<p>派生类的方法可以通过super关键字引用它们的原型。这个关键字只能在派生类中使用，而且仅限于类构造函数、实例方法和静态方法内部。在类构造函数中使用super可以调用父类构造函数。</p>
<p>ES6给类构造函数和静态方法添加了内部特性<code>[[HomeObject]]</code>，这个特性是一个指针，指向定义该方法的对象。</p>
<p>使用<code>super()</code>几个关键点：</p>
<ul>
<li><code>super</code>只能在派生类构造函数和静态方法中使用</li>
<li>不能单独引用super关键字，要么用它调用构造函数，要么用它引用静态方法</li>
<li>调用<code>super()</code>会调用父类构造函数，并将返回的实例赋值给<code>this</code></li>
<li><code>super()</code>的行为如同调用构造函数，如果需要给父类构造函数传参，则需要手动传入</li>
<li>如果没有定义类构造函数，在实例化派生类时会调用<code>super()</code>，而且会传入所有传给派生类的参数。</li>
<li>在类构造函数中，不能在调用<code>super()</code>之前引用<code>this</code></li>
<li>如果在派生类中显式定义了构造函数，则要么必须在其中调用<code>super()</code>，要么必须在其中返回一个对象</li>
</ul>
</li>
<li><p>抽象基类</p>
<ul>
<li>可供其他类继承，但本身不会被实例化</li>
<li><code>new.target</code>保存通过<code>new</code>关键字调用的类或函数<ul>
<li>通过在实例化时检测<code>new.target</code>是不是抽象基类，可以阻止对抽象基类的实例化</li>
</ul>
</li>
<li>因为原型方法在调用类构造函数之前就已经存在了，所以可以通过<code>this</code>关键字来检查相应的方法</li>
</ul>
</li>
<li><p>继承内置类型</p>
<ul>
<li>ES6类为继承内置引用类型提供了顺畅的机制，开发者可以方便地扩展内置类型</li>
</ul>
</li>
<li><p>类混入</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Javascript高级程序设计</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP基础</title>
    <url>/2022/02/17/HTTP%E5%9F%BA%E7%A1%80/HTTP%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="HTTP介绍"><a href="#HTTP介绍" class="headerlink" title="HTTP介绍"></a>HTTP介绍</h2><h3 id="http是什么，用来做什么的"><a href="#http是什么，用来做什么的" class="headerlink" title="http是什么，用来做什么的"></a>http是什么，用来做什么的</h3><p>是数据传输协议。Web浏览器、服务器和相关Web应用程序都是通过http相互通信的</p>
<h3 id="Web客户端、服务端"><a href="#Web客户端、服务端" class="headerlink" title="Web客户端、服务端"></a>Web客户端、服务端</h3><p>发送请求的一般称为客户端，响应请求的一般称为服务端。HTTP客户端和HTTP服务端共同构成了万维网的基本组件</p>
<span id="more"></span>

<h3 id="什么是资源"><a href="#什么是资源" class="headerlink" title="什么是资源"></a>什么是资源</h3><p>网络上一切内容都是资源。Web服务器是Web资源的宿主，Web资源是Web内容的源头</p>
<h3 id="什么是媒体类型"><a href="#什么是媒体类型" class="headerlink" title="什么是媒体类型"></a>什么是媒体类型</h3><p>是用来描述并标记多媒体内容，用来告诉接收端，接收到的数据是什么类型，让接收端知道怎么才能处理该文件。HTTP给每种通过Web传输的对象都打上MIME类型的数据格式标签，例如<code>Content-type: text/html</code></p>
<h3 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h3><p>统一资源标识符，有两种形式：URL和URN，用于唯一识别和定位信息资源</p>
<h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>统一资源定位符，用来描述一台特服务器上某资源的特定位置。格式：协议（如http）+服务器地址（主机地址）+ 指定服务器上的某个资源</p>
<h4 id="URN"><a href="#URN" class="headerlink" title="URN"></a>URN</h4><p>统一资源名，用资源名定位资源，与位置无关</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>​    就是一个http连接，一个http事务由一条请求命令和一条响应结果组成，通过http报文的格式化数据块进行</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>请求命令称为http方法，方法就是告诉服务器要做什么。常用方法：</p>
<ul>
<li>GET</li>
<li>PUT</li>
<li>DELETE</li>
<li>POST</li>
<li>HEAD</li>
</ul>
<h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><p>用来告知客户端请求是否成功，或者是否需要采取其他动作。每条http响应报文返回时都会带有状态码，并附带解释性原因短语</p>
<h3 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h3><p>http报文是纯文本，不是二进制，分为请求报文和响应报文，包含三个结构</p>
<ul>
<li>起始行<ul>
<li>说明用来做说明</li>
<li>说明出现了说明情况</li>
<li>格式<ul>
<li>命令 + 资源位置 + 协议版本</li>
<li>协议版本 + 状态码 + 原因短语</li>
</ul>
</li>
</ul>
</li>
<li>首部字段</li>
<li>主体<ul>
<li>包含所有类型的数据，如二进制数据也是可以</li>
<li>请求报文：发给Web服务器的数据</li>
<li>响应报文：装载发给客户端的数据</li>
</ul>
</li>
</ul>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>报文是通过TCP连接从一个地方到另一个地方，且TCP提供了无差错的数据传输、按序传输、未分段的数据流，所以报文传输是可靠的、按序的。</p>
<h4 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h4><p>解析URL，获取主机名和端口，主机名通过DNS得到IP地址，连接到特定的<code>IP:端口</code>位置，发送请求，读取响应，关闭连接</p>
<h3 id="协议版本"><a href="#协议版本" class="headerlink" title="协议版本"></a>协议版本</h3><ul>
<li>0.9，定义的初衷是获得简单的HTML对象，只支持GET请求，不支持MIME类型和各种HTTP首部</li>
<li>1.0，各种http首部，一些额外的方法，对多媒体对象的处理</li>
<li>1.0+，持久的<code>keep-alive</code>连接，虚拟主机支持，代理连接支持</li>
<li>1.1，明确语义，引入性能优化措施，删除不好的特性</li>
<li>2.0，性能优化</li>
</ul>
<h3 id="Web结构组件"><a href="#Web结构组件" class="headerlink" title="Web结构组件"></a>Web结构组件</h3><ul>
<li>代理<ul>
<li>位于客户端和服务器之间的HTTP中间实体，接受客户端所有的HTTP请求，并将这些请求转发给服务器（可能会对请求做一定的修改再转发）</li>
</ul>
</li>
<li>缓存<ul>
<li>HTTP的仓库，特殊的HTTP代理服务器，将经常使用的页面保存起来，等客户端下个请求，请求相同资源时，把缓存直接发给客户端，不再请求服务器。</li>
</ul>
</li>
<li>网关<ul>
<li>连接其他应用程序的特殊服务器，面对客户端时好像它就是服务器，而对于服务器，他又充当客户端的角色，它的主要作用是协议转换。例如HTTP/FTP网关</li>
</ul>
</li>
<li>隧道<ul>
<li>就是一个连接通道，用于在http信道上发送非http协议的资源</li>
<li></li>
</ul>
</li>
<li>Agent代理<ul>
<li>发起自动的HTTP请求的半智能客户端，说白了就是我们平时所说的浏览器，以及web机器人、爬虫等</li>
</ul>
</li>
</ul>
<h2 id="URL与资源"><a href="#URL与资源" class="headerlink" title="URL与资源"></a>URL与资源</h2><h3 id="URL作用"><a href="#URL作用" class="headerlink" title="URL作用"></a>URL作用</h3><p>URL是通过描述资源的位置来标识资源，URL包含三个部分：<code>方案://服务器位置/路径</code>。完整通用格式：<code>&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt;</code></p>
<ul>
<li>scheme:方法描述了请求资源时用了什么协议，用“:”与url其它部分隔开；</li>
<li>user:用户名描述了访问是带的用户名；</li>
<li>password:密码描述了用户名后面可能跟的密码，用“:”跟用户名隔</li>
<li>host:主机描述了网站主机名或ip地址，如果前面有用户名和密码，用@分开；</li>
<li>post:服务器当前正在监听的端口，http默认为80，https默认为443;</li>
<li>path:路劲描述了资源在服务器上的位置，用‘/’跟前面部分隔开；</li>
<li>params:参数描述了请求需要附加的参数，用“;”与其他部分隔开；</li>
<li>query:查询是用来激活服务器程序去执行某些操作，比如查询数据库等，用“?”与其余部分隔开；</li>
<li>frag:片段只在客户端使用，<strong>不发送到服务器端</strong>，用于指着某个章节</li>
</ul>
<h3 id="URL快捷方式"><a href="#URL快捷方式" class="headerlink" title="URL快捷方式"></a>URL快捷方式</h3><blockquote>
<p>相对URL</p>
</blockquote>
<p>用基础URL，推导出缺失的URL信息。基础URL可能存在的位置：</p>
<ul>
<li>在资源中显式提供<ul>
<li>HTML文档中<code>&lt;BASE&gt;</code>这个tag提供</li>
</ul>
</li>
<li>封装资源的基础URL<ul>
<li>就是找所属资源的URL作为基础</li>
</ul>
</li>
</ul>
<h4 id="自动扩展URL"><a href="#自动扩展URL" class="headerlink" title="自动扩展URL"></a>自动扩展URL</h4><ul>
<li>主机名扩展</li>
<li>历史扩展<ul>
<li>以前访问过的URL存起来，当再次输入URL时，会根据你的URL前缀进行匹配，并提供选项供你选择</li>
</ul>
</li>
</ul>
<h3 id="URL字符"><a href="#URL字符" class="headerlink" title="URL字符"></a>URL字符</h3><p>为了安全传输，不丢失信息，URL使用通用的安全字母表的字符，其他字符需要进行编码，如<code>~ 空格 %</code>。</p>
<h4 id="编码机制"><a href="#编码机制" class="headerlink" title="编码机制"></a>编码机制</h4><p>通过一种“转义”表示法来表示不安全字符的，这种转义表示法包含一个百分号（%），后面跟着两个表示字符的ASCII码的十六进制数</p>
<h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><ul>
<li>http<ul>
<li>没有用户名和密码，与通用URL格式相符</li>
</ul>
</li>
<li>https<ul>
<li>比http多了ssl，ssl为http连接提供端到端的加密过程</li>
</ul>
</li>
<li>mailto</li>
<li>ftp</li>
<li>rtsp， rtspu</li>
<li>file</li>
<li>news</li>
<li>telnet</li>
</ul>
<h2 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h2><h3 id="报文流"><a href="#报文流" class="headerlink" title="报文流"></a>报文流</h3><p>用来形容http报文像水流流动，HTTP使用术语流入、流出来描述事务处理。所有报文都会向下游流动，所有的报文发送者都是接受者的上游</p>
<h3 id="报文组成部分"><a href="#报文组成部分" class="headerlink" title="报文组成部分"></a>报文组成部分</h3><h4 id="起始行"><a href="#起始行" class="headerlink" title="起始行"></a>起始行</h4><blockquote>
<p>都是用空格分开</p>
</blockquote>
<h5 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h5><ul>
<li>方法<ul>
<li>描述服务器应该执行的操作</li>
</ul>
</li>
<li>请求URL<ul>
<li>描述要对哪一个资源执行这个方法</li>
</ul>
</li>
<li>版本<ul>
<li>告知服务器自己的版本</li>
</ul>
</li>
</ul>
<h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><ul>
<li>GET：用于请求服务器端发送某个资源</li>
<li>HEAD：跟GET方法类似，区别就是不返回主体<ul>
<li>在不获取资源下，了解资源情况</li>
<li>查看响应报文的状态码，看看对象是否存在</li>
<li>查看首部，测试资源是否被修改</li>
</ul>
</li>
<li>PUT：用于向服务器端修改、插入数据<ul>
<li>语义是，让服务器用请求报文的主体部分，创建一个由请求报文URL命名的新文档</li>
<li>PUT与POST区别：POST用于向服务器<strong>发送数据</strong>，而PUT用于向服务器的资源中<strong>存储数据</strong></li>
</ul>
</li>
<li>POST：用于向服务器端发送数据</li>
<li>TRACK：用于向服务器端请求报文在发送的过程中经过了什么修改，主要用于测试<ul>
<li>最后一站的服务器，在响应主体中携带原始收到的请求报文</li>
</ul>
</li>
<li>OPTIONS：用于请求服务器告知其支持什么功能（支持什么方法，或对某些特殊资源支持哪些方法）</li>
<li>DELETE：用于向服务器删除请求URL所指定资源</li>
<li>扩展方法其实类似于自定义方法</li>
</ul>
<h5 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h5><ul>
<li>版本</li>
<li>状态码<ul>
<li>告诉客户端发生了什么事情</li>
</ul>
</li>
<li>原因短语</li>
</ul>
<h5 id="状态码-1"><a href="#状态码-1" class="headerlink" title="状态码"></a>状态码</h5><ul>
<li>100-199 信息性状态码<ul>
<li>100：说明收到了请求的初始部分，请客户端继续，发送了这个状态码之后，服务器在收到请求之后必须进行响应。<ul>
<li>使用这个状态码的目的：客户端有一个实体的主体部分要发给服务器，但希望发送前查看一下服务器是否能接受</li>
</ul>
</li>
</ul>
</li>
<li>200-299 成功状态码 （常见200表示请求成功）<ul>
<li>200：请求没问题，实体的主体部分包含了所请求的资源</li>
<li>201：用于创建服务器对象的请求（比如PUT），响应的主体部分应该包含各种引用了已创建的资源的URL</li>
<li>202：请求已被接受，但还未进行处理</li>
<li>203：实体首部包含的信息不是来源与源服务器</li>
<li>204：没有实体的主体部分，常出现在刷新一个表单页面</li>
<li>205：告知浏览器清除当前页面中所有HTML的表单</li>
</ul>
</li>
<li>300-399 重定向状态码 （常见302重定向）<ul>
<li>301：请求的URL被移除时使用，响应首部应带有Location字段，包含资源现在所处的URL</li>
<li>302：与301类型，会用Location字段的URL发起请求，但下一次还会用旧的URL进行请求</li>
<li>304：资源未被修改，响应实体的主体部分不应该有内容</li>
<li>305：必须通过一个代理来访问资源，代理地址在Location字段中</li>
<li>307：与302一样，区别：307给http1.1用的，而302时给http1.0用的</li>
</ul>
</li>
<li>400-499 客户端错误状态码 （常见404，请求资源不存在）<ul>
<li>401：还没认证</li>
<li>403：请求被拒绝</li>
<li>405：请求的方法，服务器不支持。应该看看响应首部的allow字段，查看符合可以用哪些方法</li>
</ul>
</li>
<li>500-599 服务端错误状态码<ul>
<li>501：请求超出服务器的能力范围，如使用了服务器不支持的方法。与405区别：简单来说，405是指服务器方法能看懂，但不支持使用，而501是指服务器连方法都没看懂</li>
<li>503：服务器暂时不能提供服务</li>
<li>505：协议不支持</li>
</ul>
</li>
</ul>
<h4 id="首部"><a href="#首部" class="headerlink" title="首部"></a>首部</h4><p>可以有0个或多个首部，每个首部包含一个名字，后面跟着冒号，然后一个可选空格，接着是一个值。</p>
<p>有五类</p>
<ul>
<li>通用首部：请求报文和响应报文都可以用<ul>
<li>Connection</li>
<li>Date：用于构建报文的时间和日期</li>
<li>MIME-Version：发送端的MIME版本</li>
<li>Update：发送端想升级使用的版本或协议</li>
<li>via：显示报文经过的中间节点</li>
<li>Cache-Control</li>
<li>Pragma</li>
</ul>
</li>
<li>请求首部<ul>
<li>信息性首部<ul>
<li>User-Agent：将发起请求的应用程序名称告诉给服务器</li>
<li>Host：接受请求的服务器的主机名和端口号</li>
</ul>
</li>
<li>Accept首部：客户端希望接受的数据类型</li>
<li>条件请求首部<ul>
<li>Expect：允许客户端列出某请求所要求的服务器行为</li>
<li>If-Match：如果实体标记与文档当前的实体标记相匹配，就获取这份文档</li>
<li>If-Modified-Since：除非在某个指定的日期之后资源被修改过，否则就限制这个请求</li>
<li>If-None-Match：如果提供的实体标记与当前文档的标记不相符，就获取文档</li>
<li>If-Range：允许对文档的某个范围进行条件请求</li>
<li>If-Unmodified-Since：除非在某个指定日期之后资源没有被修改过，否则就限制这个请求</li>
</ul>
</li>
<li>安全请求首部<ul>
<li>Authorization：包含了客户端提供给服务器，以便对其自身进行认证的数据</li>
<li>Cookie：客户端用它向服务器传送一个令牌————它并不是真正的安全首部，但确实隐含了安全功能</li>
<li>Cookie2：用来说明请求端支持的cookie版本</li>
</ul>
</li>
<li>代理请求首部</li>
</ul>
</li>
<li>响应首部<ul>
<li>信息性首部<ul>
<li>Server：告知客户端自己服务器信息</li>
<li>Age：响应持续时间</li>
</ul>
</li>
<li>协商首部</li>
<li>安全响应首部<ul>
<li>Proxy-Authenticate：来自代理的对客户端的质询列表</li>
<li>Set-Cookie：不是真正的安全首部，但隐含有安全功能；可以在客户端设置一个令牌，以便服务器对客户端</li>
<li>Set-Cookie2：与Set-Cookie类似</li>
<li>WWW-Authenticate：来自服务器的对客户端的质询列表</li>
</ul>
</li>
</ul>
</li>
<li>实体首部：描述主体的长度和内容，或者资源本身<ul>
<li>信息性首部<ul>
<li>Allow：列出了可以对此实体执行的请求方法</li>
<li>Location：告知客户端实体实际上位于何处；用于将接收端丁香到资源的位置上去</li>
</ul>
</li>
<li>内容首部<ul>
<li>Content-Base：解析主体中的相对URL时使用的基础URL</li>
<li>Content-Encoding：对主体执行的任意编码方式</li>
<li>Content-Language：理解主体时最适宜使用的自然语言</li>
<li>Content-Length：主体的长度或者尺寸</li>
<li>Content-Location：资源实际所处的位置</li>
<li>Content-MD5 ：主体的MD5校验和</li>
<li>Content-Range：在整个资源中此实体表示的字节范围</li>
<li>Content-Type：这个主体的对象类型</li>
</ul>
</li>
<li>实体缓存首部<ul>
<li>ETag：与此实体相关的实体标记</li>
<li>Expires ： 实体不再有效，要从原始的源端再次获取此实体的日期和时间</li>
<li>Last-Modified：这个实体最后一次被修改的日期和时间</li>
</ul>
</li>
</ul>
</li>
<li>扩展首部：扩展没有定义的新首部</li>
</ul>
<h4 id="主体"><a href="#主体" class="headerlink" title="主体"></a>主体</h4><p>可以是任意数据类型</p>
<h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><p>是一个可靠数据管道，TCP为HTTP提供一条可靠的比特传输管道，从TCP连接一段流入的字节，会从另一端以原有的顺序、正确地流出。</p>
<p>TCP流是分段的，由IP分组传送。TCP连接通过四个值来唯一确定<code>源IP，源端口、目的IP、目的端口</code></p>
<h3 id="TCP性能优化"><a href="#TCP性能优化" class="headerlink" title="TCP性能优化"></a>TCP性能优化</h3><h4 id="HTTP主要的时延及产生原因"><a href="#HTTP主要的时延及产生原因" class="headerlink" title="HTTP主要的时延及产生原因"></a>HTTP主要的时延及产生原因</h4><p>连接、传输和处理时延</p>
<p>原因：</p>
<ol>
<li>假如没有主机名和IP的映射，则DNS解析需要时间</li>
<li>建立一条TCP连接需要时间</li>
<li>建立连接后，传输数据需要时间，对数据做处理也需要时间</li>
<li>Web服务器返回响应需要时间</li>
<li>当然还有其他因素，比如硬件、网络负载，以及报文尺寸等</li>
</ol>
<h4 id="TCP相关时延"><a href="#TCP相关时延" class="headerlink" title="TCP相关时延"></a>TCP相关时延</h4><ul>
<li>TCP连接建立握手<ul>
<li>握手过程<ol>
<li>客户端发送一个小的TCP分组，并设置SYN标记</li>
<li>服务器接收到连接后，回送一个TCP分组，并将SYN和ACK置位</li>
<li>客户端接受到分组后，会送一条确认信息，通知服务器连接已成功建立。此步允许在确认分组中发送数据</li>
</ol>
</li>
</ul>
</li>
<li>TCP慢启动拥塞控制<ul>
<li>起初会限制连接的最大速度，如果数据传输成功，则会随着时间的推移提高传输的速度</li>
</ul>
</li>
</ul>
<h3 id="HTTP连接处理"><a href="#HTTP连接处理" class="headerlink" title="HTTP连接处理"></a>HTTP连接处理</h3><p>Connection首部，可以包含三个部分</p>
<ul>
<li>HTTP首部字段名，列出了只与此有关的首部</li>
<li>任意标签值，用于描述此链接的非标准选项</li>
<li>值close，说明操作完成之后需关闭这条持久连接</li>
</ul>
<p>Connection首部不能转发出去，报文转发出去前，一定要删除Connection首部，只能用于一跳</p>
<h4 id="串行事务处理时延"><a href="#串行事务处理时延" class="headerlink" title="串行事务处理时延"></a>串行事务处理时延</h4><p>每个事务一个接着一个连接</p>
<p><img src="/2022/02/17/HTTP%E5%9F%BA%E7%A1%80/HTTP%E5%9F%BA%E7%A1%80/link.png" alt="link"></p>
<p>优化</p>
<ul>
<li>并行连接<ul>
<li>通过多条TCP连接发起请求</li>
<li>不一定更快<ul>
<li>网络带宽不够</li>
<li>打开大量连接会消耗很多内存资源，从而引发性能问题</li>
</ul>
</li>
</ul>
</li>
<li>持久连接<ul>
<li>重用TCP连接，以消除连接和关闭时延</li>
</ul>
</li>
<li>管道化连接<ul>
<li>共享TCP连接发起并发的HTTP请求</li>
</ul>
</li>
</ul>
<h4 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h4><p>重用已对服务器打开的空闲连接，就可以避免连接建立的时延，还可以避免慢启动的拥塞适应阶段。</p>
<p>持久连接有两种类型</p>
<ul>
<li>http1.0：“keep-alive”<ul>
<li>请求报文首部需要加上connection：“keep-alive”，且响应报文也要有这个字段，才能建立持久连接</li>
<li>代理和网关必须在将报文转发出去或将其高速缓存之前删除connection字段</li>
</ul>
</li>
<li>htttp1.1：“presistent”</li>
</ul>
<h4 id="管道话连接"><a href="#管道话连接" class="headerlink" title="管道话连接"></a>管道话连接</h4><blockquote>
<p>HTTP/1.1允许在持久连接上可选地使用请求管道。这是在keep-alive连接上的进一步性能优化。在响应到达之前，可以将多条请求放入队列。当第一条请求通过网络流向地球另一端的服务器时，第二条和第三条请求也可以开始发送了。在高时延网络条件下，这样做可以降低网络的环回时间，提高性能。</p>
</blockquote>
<p>管道连接的限制</p>
<ul>
<li>如果不是持久连接就不要使用管道连接</li>
<li>接收端必须按收到请求报文的顺序返回响应报文，因为HTTP报文中没有序列号标签。所以必须靠按序发送响应报文来达到“数据对应”</li>
<li>发送端应该做好数据没有发送完连接就关闭的准备并开始重新发送数据。</li>
<li>HTTP客户端不应该用管道化的方式发送会产生副作用的请求（比如POST）。</li>
</ul>
<h3 id="关闭连接的奥秘"><a href="#关闭连接的奥秘" class="headerlink" title="关闭连接的奥秘"></a>关闭连接的奥秘</h3><h4 id="正常关闭"><a href="#正常关闭" class="headerlink" title="正常关闭"></a>正常关闭</h4><p>应用程序应先关闭自己的输出信道，然后等待连接另一端的对等实体关闭它的输出信道，两端都告诉对方不会再发送数据之后，连接就会被完全关闭</p>
<p>但实际上，无法确保对等实体会实现半关闭，或对齐检查，所以只能关闭输出信道之后，周期性的检查自己的输入信道有无接受到数据，设定一段时间之后无数据通过，则关闭连接。</p>
]]></content>
      <categories>
        <category>HTTP权威指南</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
</search>
